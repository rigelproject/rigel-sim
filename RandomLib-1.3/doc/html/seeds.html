<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RandomLib: The seed</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RandomLib</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">The seed </div>  </div>
</div>
<div class="contents">
<div class="textblock"><center> Back to <a class="el" href="organization.html">Code organization</a>. Forward to <a class="el" href="integer.html">Random integers</a>. Up to <a class="el" href="index.html#contents">Contents</a>. </center><p>The state of MT19937 is given by a set of 19937 bits. (The discussion here is illustrated with the MT19937 generator. The properties of the SFMT19937 generator are similar.) Over the course of the period of the generator all possible states are visited. (The state consisting of all zeros is disallowed.) Thus the sequence consists of <em>X<sub><em>i</em></sub></em> where <em>X<sub><em>i</em></em> + <em>L</em></sub> = <em>X<sub><em>i</em></sub></em> and <em>L</em> = 2<sup>19937</sup> - 1. When using the generator we need to specify a starting state <em>j</em> so that the sequence is then <em>Y<sub><em>i</em></em>; <em>j</em></sub> = <em>X<sub><em>i</em></em> + <em>j</em></sub></p>
<p>However, rather than specified an unwieldy set of 19937 bits, we instead specify a vector <em>s</em> of 32-bit integers. The length of <em>s</em> is arbitrary (it can even be zero), however in most applications, its length will be small -- often a length of 1 provides sufficient "seed
space". The process of seeding MT19937 consists of "mixing" the <em>s</em> in some way to provide the necessary starting state <em>j</em>. Thus the random sequence is now viewed as <em>Z<sub><em>i</em></em>; <em>s</em></sub> = <em>Y<sub><em>i</em></em>; <em>j</em>(<em>s</em>)</sub> = <em>X<sub><em>i</em></em> + <em>j</em>(<em>s</em>)</sub>.</p>
<p>Now the user's view of a typical random number generator is that <em>Z<sub><em>i</em></em>; <em>s</em></sub> and <em>Z<sub><em>i</em></em>; <em>s</em>'</sub> are <em>independent</em> provided <em>s</em> and <em>s'</em> are distinct. A necessary condition for independence is that |<em>j</em>(<em>s</em>) - <em>j</em>(<em>s'</em>)| &gt; <em>R</em> where <em>R</em> is the maximum number of random numbers needed for a particular seed. If we assume that the seeding function <em>j</em>(<em>s</em>) produces randomly distributed starting positions and if maximum number of seeds we might use is <em>S</em>, then the probability of overlapping sequences, i.e., that |<em>j</em>(<em>s</em>) - <em>j</em>(<em>s'</em>)| &lt; <em>R</em> for some <em>s</em> and <em>s'</em> is <em>S<sup>2</sup><em>R</em> /</em> <em>L</em>.</p>
<p>Suppose we take <em>R</em> = 10<sup>200</sup> and <em>S</em> = 10<sup>100</sup>, then the probability of overlap is a tiny 10<sup>-5600</sup>. (On the other hand with rand() for which the period <em>L</em> is 2<sup>32</sup>, we have an appreciable probability of overlap with <em>R</em> = 2000 and <em>S</em> = 1000.) This means that we can safely assume that the sequences <em>Z<sub><em>i</em></em>; <em>s</em></sub> as independent and this then means that from the user's perspective the most useful representation of the state of the generator is [<em>i</em>, <em>s</em>] which is given by [Count(), Seed()].</p>
<p>It's frequently desirable to start each run of a code with a different "arbitrary" seed. The current time (in seconds) is frequently used for this purpose. However, if many runs are started simultaneously, many are likely to use the same seed. Random::SeedWord() can instead be called. This returns an unsigned long generated from various sources (/dev/urandom, the microsecond clock, etc.).</p>
<p>Because Random::SeedWord() returns a result in [0, 2<sup>32</sup>), there's a strong probability of collisions after 2<sup>16</sup> invocations. If you expect that your code will be invoked more often than that, then instead use Random::SeedVector() to seed the generator. This returns a vector of unsigned longs which is almost certainly unique. However successive calls to Random::SeedVector() may return the same result. If multiple random number sequences are required, for example in a multi-threaded application, then Random::SeedVector() can be called once by the master thread to define a master seed and each slave thread would set its seed to a vector obtained by appending a thread index to the master seed. The default constructor for Random sets the seed to the vector [Random::SeedVector()].</p>
<p>Whenever random numbers are used it is important to record the seed used. Without this information, it will be impossible to repeated (e.g., to track down a bug). Random::SeedString() returns the seed vector as a string allowing it to be printed on standard output easily. Thus </p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomLib::Random</a> r;
  r.Reseed();            <span class="comment">// sets seed to [Random::SeedVector()]</span>
  std::cout &lt;&lt; <span class="stringliteral">&quot;Random seed set to &quot;</span> &lt;&lt; r.SeedString() &lt;&lt; \n<span class="stringliteral">&quot;;</span>
</pre></div><p>The seed may be set with the constructor as follows: </p>
<div class="fragment"><pre class="fragment">  <span class="keyword">using</span> <a class="code" href="namespaceRandomLib.html#a9fa363d3530b1c14370988abfc707231">RandomLib::Random</a>;
  Random r1;                  <span class="comment">// set seed to []</span>
  Random r2(1234);            <span class="comment">// set seed to [1234]</span>
  Random r3(<span class="stringliteral">&quot;[1,2,3,4]&quot;</span>);     <span class="comment">// set seed to [1,2,3,4]</span>
  <span class="keywordtype">unsigned</span> v[] = {1,2,3,4};
  Random r4(v, v+4);          <span class="comment">// seed set via iterators</span>
  Random r5(std::vector&lt;unsigned&gt;(v, v+4)); <span class="comment">// seed set via vector</span>
  Random r6(Random::SeedWord());            <span class="comment">// use a &quot;random&quot; integer seed</span>
  Random r7(Random::SeedVector());          <span class="comment">// use a &quot;unique&quot; vector seed</span>
</pre></div><p> After a random object is created, you can change its seed with Reseed(...) with </p>
<div class="fragment"><pre class="fragment">  <span class="keyword">using</span> <a class="code" href="namespaceRandomLib.html#a9fa363d3530b1c14370988abfc707231">RandomLib::Random</a>;
  Random r;                   <span class="comment">// created with seed []</span>
  r.Reseed();                 <span class="comment">// use a &quot;unique&quot; vector seed</span>
  r.Reseed(1234);             <span class="comment">// set seed to [1234]</span>
  r.Reseed(<span class="stringliteral">&quot;[1,2,3,4]&quot;</span>);      <span class="comment">// set seed to [1,2,3,4]</span>
  <span class="keywordtype">unsigned</span> v[] = {1,2,3,4};
  r.Reseed(v, v+4);           <span class="comment">// seed set via iterators</span>
  r.Reseed(std::vector&lt;unsigned&gt;(v, v+4)); <span class="comment">// seed set via vector</span>
  r.Reseed(Random::SeedWord());            <span class="comment">// use a &quot;random&quot; integer seed</span>
  r.Reseed(Random::SeedVector());          <span class="comment">// same as r.Reseed()</span>
  r.Reseed(std::vector&lt;unsigned&gt;(0));      <span class="comment">// set seed to []</span>
</pre></div><p> Tools are provided to convert between the string and vector representations of a seed </p>
<div class="fragment"><pre class="fragment">  <span class="keyword">using</span> <a class="code" href="namespaceRandomLib.html#a9fa363d3530b1c14370988abfc707231">RandomLib::Random</a>;
  std::vector&lt;unsigned long&gt; seed(Random::StringToVector(<span class="stringliteral">&quot;[1,2,3,4]&quot;</span>);
  std::cout &lt;&lt; Random::VectorToString(seed) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
</pre></div><p>The original C interface for the Mersenne Twister provided two seed-setting interfaces: (a) init_genrand, which took a single unsigned long as argument and (b) init_by_array, which took an array (length &gt; 0) of unsigned longs as an argument. Thus, the set of allowed seeds was {<em>a</em>, [<em>a</em>], [<em>a</em>, <em>b</em>], [<em>a</em>, <em>b</em>, <em>c</em>], ...}, where <em>a</em> and [<em>a</em>] were distinct. But this then presents a confusing interface to the user. In addition, it's not clear how best to report back the seed to the user.</p>
<p>In this implementation, seeds are always vectors (of arbitrary length, including zero). Thus the set of allowable seeds is {[], [<em>a</em>], [<em>a</em>, <em>b</em>], [<em>a</em>, <em>b</em>, <em>c</em>], ...} which is easily and unambiguously represented by the STL vector container. Note also that [], [0], [0, 0], etc. are all distinct as are [<em>a</em>], [<em>a</em>, 0], [<em>a</em>, 0, 0]. Seeding with Reseed(<em>n</em>) merely sets the seed to a vector of length one, [<em>n</em>].</p>
<p>Also, since the init_by_array routine in the original MT19937 implementation has some weaknesses (the most serious of which is distinct short seeds can result in the same state, this library uses, by default, SFMT's method for mixing the seed into the random generator state. (This method has been adopted by the proposed C++0x standard, see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">P. Becker, Working Draft, Standard for Programming Language C++, Oct. 2007, Sec. 26.4.7.1</a>.) In this implementation, this mixing class is called MixerSFMT.</p>
<p>Two other mixing classes MixerMT0 and MixerMT1 are provided. MixerMT0 implements the mixing methods in MT19937 and MT19937_64. These methods have some defects which are partially corrected by the MixerMT1 classes with are described in the (superseded) proposal to the C++0x standards, Brown, et al., <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2079.pdf">Random Number Generation in C++0x: A Comprehensive Proposal, version 3</a>.</p>
<center> Back to <a class="el" href="organization.html">Code organization</a>. Forward to <a class="el" href="integer.html">Random integers</a>. Up to <a class="el" href="index.html#contents">Contents</a>. </center> </div></div>
<hr class="footer"/><address class="footer"><small>Generated on Sat Jan 21 2012 for RandomLib by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
