<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RandomLib: Random real numbers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RandomLib</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Random real numbers </div>  </div>
</div>
<div class="contents">
<div class="textblock"><center> Back to <a class="el" href="integer.html">Random integers</a>. Forward to <a class="el" href="other.html">Other random results</a>. Up to <a class="el" href="index.html#contents">Contents</a>. </center><p>The Random class generates two classes of uniform real results: <a class="el" href="real.html#fixed">fixed</a> point numbers (where the spacing between possible results is a constant) and <a class="el" href="real.html#floating">floating</a> point numbers (where the spacing between possible results varies).</p>
<h2><a class="anchor" id="fixed"></a>
Fixed-point real numbers</h2>
<p>The results returned by Fixed(), FixedU(), FixedN(), FixedW(), FixedO(), and FixedC() are "fixed-point reals" with precision <em>p</em>. These are of the form <em>i</em> / 2<sup><em>p</em></sup> where <em>i</em> is an integer. If, for real data type RealType, we restrict <em>p</em> &gt; 0 and <em>p</em> &lt;= std::numeric_limits&lt;RealType&gt;::digits, then all such numbers in [-1,1] are representable. For <em>p</em> = 3, the set of numbers in [0,1] is {0, 1/8, 1/4, 3/8, 1/2, 5/8, 3/4, 7/8, 1}.</p>
<p>The results returned FixedS() are of "offset fixed-point reals" with precision <em>p</em>. These are of the form (<em>i</em> + 1/2) / 2<sup><em>p</em></sup> where <em>i</em> is an integer. If, for real data type RealType, we restrict <em>p</em> &gt; 0 and <em>p</em> &lt;= std::numeric_limits&lt;RealType&gt;::digits, then all such numbers in (-1/2,1/2) are representable. (This only "works" for radix 2 systems; with larger bases, the results can't be represented exactly.) Note that possibly "exceptional" numbers, -1/2, 0, and 1/2, are not included in this set. For <em>p</em> = 3, the set of numbers in (-1/2,1/2) is {-7/16, -5/16, -3/16, -1/16, 1/16, 3/16, 5/16, 7/16}.</p>
<h2><a class="anchor" id="floating"></a>
Floating-point real numbers</h2>
<p>The results returned by Float(), FloatU(), FloatN(), FloatW() are "floating-point reals" with precision <em>p</em> and exponent range <em>e</em>. The possible results for such floating numbers in [-1,1] consist of</p>
<ul>
<li><em>f</em> / 2<sup><em>p</em> + <em>s</em></sup> for <em>f</em> in (2<sup><em>p</em> - 1</sup>, 2<sup><em>p</em></sup>] and <em>s</em> in [0,<em>e</em>],</li>
<li><em>f</em> / 2<sup><em>p</em> + <em>s</em></sup> for <em>f</em> in [-2<sup><em>p</em></sup>, -2<sup><em>p</em> - 1</sup>) and <em>s</em> in [0,<em>e</em>],</li>
<li><em>f</em> / 2<sup><em>p</em> + <em>e</em></sup> for <em>f</em> in [-2<sup><em>p</em> - 1</sup>, 2<sup><em>p</em> - 1</sup>].</li>
</ul>
<p>For real data type RealType, such numbers are representable if</p>
<ul>
<li><em>p</em> &gt; 0</li>
<li><em>e</em> &gt;= 0</li>
<li><em>p</em> &lt;= std::numeric_limits&lt;RealType&gt;::digits</li>
<li><em>p</em> + <em>e</em> &lt;= std::numeric_limits&lt;RealType&gt;::digits - std::numeric_limits&lt;RealType&gt;::min_exponent</li>
</ul>
<p>For <em>e</em> = 0, the numbers become the <a class="el" href="real.html#fixed">fixed</a> point numbers with precision <em>p</em>.</p>
<p>Here is an example of the floating point points with <em>p</em> = 3 and <em>e</em> = 2 together with the probabilities yielded by Float(), FloatU(), FloatN().</p>
<center> <table class="doxtable">
<caption align="bottom">Floats with <em>p</em> = 3, <em>e</em> = 2</caption>
<tr>
<th><em>X</em> </th><th>prob(Float() = <em>X</em>) </th><th>prob(FloatU() = <em>X</em>) </th><th>prob(FloatN() = <em>X</em>) </th></tr>
<tr>
<td>0 </td><td>1/32 </td><td>0 </td><td>0.5/32 </td></tr>
<tr>
<td>1/32</td><td>1/32 </td><td>1/32 </td><td>1/32 </td></tr>
<tr>
<td>2/32</td><td>1/32 </td><td>1/32 </td><td>1/32 </td></tr>
<tr>
<td>3/32</td><td>1/32 </td><td>1/32 </td><td>1/32 </td></tr>
<tr>
<td>4/32</td><td>1/32 </td><td>1/32 </td><td>1/32 </td></tr>
<tr>
<td>5/32</td><td>1/32 </td><td>1/32 </td><td>1/32 </td></tr>
<tr>
<td>6/32</td><td>1/32 </td><td>1/32 </td><td>1/32 </td></tr>
<tr>
<td>7/32</td><td>1/32 </td><td>1/32 </td><td>1/32 </td></tr>
<tr>
<td>4/16</td><td>1/16 </td><td>1/32 </td><td>1.5/32 </td></tr>
<tr>
<td>5/16</td><td>1/16 </td><td>1/16 </td><td>1/16 </td></tr>
<tr>
<td>6/16</td><td>1/16 </td><td>1/16 </td><td>1/16 </td></tr>
<tr>
<td>7/16</td><td>1/16 </td><td>1/16 </td><td>1/16 </td></tr>
<tr>
<td>4/8 </td><td>1/8 </td><td>1/16 </td><td>1.5/16 </td></tr>
<tr>
<td>5/8 </td><td>1/8 </td><td>1/8 </td><td>1/8 </td></tr>
<tr>
<td>6/8 </td><td>1/8 </td><td>1/8 </td><td>1/8 </td></tr>
<tr>
<td>7/8 </td><td>1/8 </td><td>1/8 </td><td>1/8 </td></tr>
<tr>
<td>1 </td><td>0 </td><td>1/8 </td><td>0.5/8 </td></tr>
</table>
</center><p>The description of floating-point numbers assumes that the underlying hardware supports denormalized numbers. This is the case with most modern computers. The code attempts to deal also with older hardware where there's a gap between 0 and 1/2<sup><em>e</em> + 1</sup>, but this has not been tested.</p>
<h2><a class="anchor" id="reals"></a>
Summary of real number routines</h2>
<p>The following table provides a succinct definition of each of the member functions of Random routines that return a real result. Here <em>u</em> is a uniformly distributed random number in (0,1). This is drawn from a continuous distribution; i.e., it may be thought of as consisting of a binary point followed by an infinite sequence of random binary bits. (This is just a useful conceptual framework. None of the implementations of these functions require an explicit realization of <em>u</em>.)</p>
<p>The term "fixed" means a fixed-point real with precision <em>p</em>, and we have <em>h</em> = 1/2<sup><em>p</em></sup> (the smallest positive fixed-point number). The term "float" means a floating-point real with precision <em>p</em> and exponent range <em>e</em>.</p>
<center> <table class="doxtable">
<caption align="bottom">Definitions of routines returning reals</caption>
<tr>
<th>routine </th><th>mnemonic </th><th>definition </th></tr>
<tr>
<td>Fixed() </td><td>default (down) </td><td>round <em>u</em> down to previous fixed </td></tr>
<tr>
<td>FixedU() </td><td>upper </td><td>round <em>u</em> up to next fixed </td></tr>
<tr>
<td>FixedN() </td><td>nearest </td><td>round <em>u</em> to nearest fixed </td></tr>
<tr>
<td>FixedW() </td><td>wide </td><td>round 2<em>u</em> - 1 to nearest fixed </td></tr>
<tr>
<td>FixedS() </td><td>symmetric </td><td>round <em>u</em> - 1/2 to nearest offset fixed </td></tr>
<tr>
<td>FixedO() </td><td>open </td><td>round (1 - <em>h</em>)<em>u</em> up to nearest fixed </td></tr>
<tr>
<td>FixedC() </td><td>closed </td><td>round (1 + <em>h</em>)<em>u</em> down to nearest fixed </td></tr>
<tr>
<td>Float() </td><td>default (down) </td><td>round <em>u</em> down to previous float </td></tr>
<tr>
<td>FloatU() </td><td>upper </td><td>round <em>u</em> up to next float </td></tr>
<tr>
<td>FloatN() </td><td>nearest </td><td>round <em>u</em> to nearest float </td></tr>
<tr>
<td>FloatW() </td><td>wide </td><td>round 2<em>u</em> - 1 to nearest float </td></tr>
</table>
</center><p>The precision and exponent range are determined as follows. Each of the fixed-point routines comes in 3 variants, for example,</p>
<ul>
<li>Fixed&lt;RealType,p&gt;() -- return fixed-point real of type RealType, precision <em>p</em>;</li>
<li>Fixed&lt;RealType&gt;() -- as above with <em>p</em> = std::numeric_limits&lt;RealType&gt;::digits;</li>
<li>Fixed() -- as above with RealType = double.</li>
</ul>
<p>Similarly each of the floating-point routines comes in 3 variants, for example,</p>
<ul>
<li>Float&lt;RealType,p,e&gt;() -- return floating-point real of type RealType, precision <em>p</em>, exponent range <em>e</em>;</li>
<li>Float&lt;RealType&gt;() -- as above with <em>p</em> = std::numeric_limits&lt;RealType&gt;::digits and <em>e</em> = - std::numeric_limits&lt;RealType&gt;::min_exponent;</li>
<li>Float() -- as above with RealType = double.</li>
</ul>
<p>Typical values of digits and min_exponent are given by </p>
<center> <table class="doxtable">
<caption align="bottom">Typical parameters for real types</caption>
<tr>
<th>type </th><th>digits </th><th>-min_exponent </th></tr>
<tr>
<td>float </td><td>24 </td><td>125 </td></tr>
<tr>
<td>double </td><td>53 </td><td>1021 </td></tr>
<tr>
<td>long double </td><td>64 </td><td>16381 </td></tr>
<tr>
<td>long double (Power PC)</td><td>106</td><td>968 </td></tr>
<tr>
<td>long double (Sun)</td><td>113 </td><td>16494 </td></tr>
</table>
</center><p>In the following tables, the columns have the following meanings</p>
<ul>
<li>"min" and "max" give the bounds on the returned results;</li>
<li>"num" gives the number of distinct results;</li>
<li>"prob" gives the probability of each result.</li>
</ul>
<p>next(X) is the next representable float following X. prev(X) is the previous representable float preceding X.</p>
<center> <table class="doxtable">
<caption align="bottom">Properties of routines returning reals</caption>
<tr>
<th>routine </th><th>min </th><th>max </th><th>num </th><th>prob </th></tr>
<tr>
<td>Fixed() </td><td>0 </td><td>1-<em>h</em> </td><td>2<sup><em>p</em></sup> </td><td><em>h</em> </td></tr>
<tr>
<td>FixedU() </td><td><em>h</em> </td><td>1 </td><td>2<sup><em>p</em></sup> </td><td><em>h</em> </td></tr>
<tr>
<td>FixedN() </td><td>0 </td><td>1 </td><td>2<sup><em>p</em></sup> + 1 </td><td><em>h</em> (<em>h</em>/2 at endpoints) </td></tr>
<tr>
<td>FixedW() </td><td>-1 </td><td>1 </td><td>2<sup><em>p</em>+1</sup> + 1 </td><td><em>h</em>/2 (<em>h</em>/4 at endpoints) </td></tr>
<tr>
<td>FixedS() </td><td>-(1-<em>h</em>)/2 </td><td>(1-<em>h</em>)/2 </td><td>2<sup><em>p</em></sup> </td><td><em>h</em> </td></tr>
<tr>
<td>FixedO() </td><td><em>h</em> </td><td>1-<em>h</em> </td><td>2<sup><em>p</em></sup>-1 </td><td><em>h</em>/(1-<em>h</em>) </td></tr>
<tr>
<td>FixedC() </td><td>0 </td><td>1 </td><td>2<sup><em>p</em></sup>+1 </td><td><em>h</em>/(1+<em>h</em>) </td></tr>
<tr>
<td>Float() </td><td>0 </td><td>1-<em>h</em> </td><td>2<sup><em>p</em></sup>(1+<em>e</em>/2) </td><td>min(1,next(<em>X</em>))-<em>X</em> </td></tr>
<tr>
<td>FloatU() </td><td>1/2<sup><em>p</em>+<em>e</em></sup> </td><td>1 </td><td>2<sup><em>p</em></sup>(1+<em>e</em>/2) </td><td><em>X</em>-max(0,prev(<em>X</em>)) </td></tr>
<tr>
<td>FloatN() </td><td>0 </td><td>1 </td><td>2<sup><em>p</em></sup>(1+<em>e</em>/2)+1 </td><td>(min(1,next(<em>X</em>))-max(0,prev(<em>X</em>)))/2 </td></tr>
<tr>
<td>FloatW() </td><td>-1 </td><td>1 </td><td>2<sup><em>p</em>+1</sup>(1+<em>e</em>/2)+1 </td><td>(min(1,next(<em>X</em>))-max(-1,prev(<em>X</em>)))/4 </td></tr>
</table>
</center><p>From these definitions, we can show that:</p>
<ul>
<li>probability(Fixed() &lt; <em>X</em>) = <em>X</em>) for all representable fixed-point numbers <em>X</em> in [0,1];</li>
<li>probability(Float() &lt; <em>X</em>) = <em>X</em>) for all representable floating-point numbers <em>X</em> in [0,1];</li>
<li>probability(FixedU() &lt;= <em>X</em>) = <em>X</em>) for all representable fixed-point numbers <em>X</em> in [0,1];</li>
<li>probability(FloatU() &lt;= <em>X</em>) = <em>X</em>) for all representable floating-point numbers <em>X</em> in [0,1];</li>
<li>probability(FixedN() &lt; <em>X</em>) = <em>X</em>) for all <em>X</em> in (0,1) midway between representable fixed-point numbers <em>X</em> in [0,1];</li>
<li>probability(FloatN() &lt; <em>X</em>) = <em>X</em>) for all <em>X</em> in (0,1) midway between representable floating-point numbers <em>X</em> in [0,1].</li>
</ul>
<p>We can easily show that certain distributions are equivalent: </p>
<center> <table class="doxtable">
<caption align="bottom">Equivalences between routines returning reals</caption>
<tr>
<th>Function </th><th>Equivalent </th></tr>
<tr>
<td>FixedU&lt;RealType,p&gt;() </td><td>Fixed&lt;RealType,p&gt;() + h </td></tr>
<tr>
<td>FixedU&lt;RealType,p&gt;() </td><td>1 - Fixed&lt;RealType,p&gt;() </td></tr>
<tr>
<td>FixedN&lt;RealType,p&gt;() </td><td>Boolean() ? Fixed&lt;RealType,p&gt;() : FixedU&lt;RealType,p&gt;() </td></tr>
<tr>
<td>FixedN&lt;RealType,p&gt;() </td><td>1 - FixedN&lt;RealType,p&gt;() </td></tr>
<tr>
<td>FixedO&lt;RealType,p&gt;() </td><td>1 - FixedO&lt;RealType,p&gt;() </td></tr>
<tr>
<td>FixedC&lt;RealType,p&gt;() </td><td>1 - FixedC&lt;RealType,p&gt;() </td></tr>
<tr>
<td>FixedS&lt;RealType,p&gt;() </td><td>Fixed&lt;RealType,p&gt;() - (1-h)/2 </td></tr>
<tr>
<td>FixedS&lt;RealType,p&gt;() </td><td>- FixedS&lt;RealType,p&gt;() </td></tr>
<tr>
<td>FixedW&lt;RealType,p&gt;() </td><td>(Boolean() ? 1 : -1) FixedN&lt;RealType,p&gt;() </td></tr>
<tr>
<td>FixedW&lt;RealType,p&gt;() </td><td>- FixedW&lt;RealType,p&gt;() </td></tr>
<tr>
<td>FixedW&lt;RealType,p-1&gt;() </td><td>2 FixedN&lt;RealType,p&gt;() - 1 </td></tr>
<tr>
<td>FloatN&lt;RealType,p,e&gt;() </td><td>Boolean() ? Float&lt;RealType,p,e&gt;() : FloatU&lt;RealType,p,e&gt;() </td></tr>
<tr>
<td>FloatW&lt;RealType,p,e&gt;() </td><td>(Boolean() ? 1 : -1) FloatN&lt;RealType,p,e&gt;() </td></tr>
<tr>
<td>FloatW&lt;RealType,p,e&gt;() </td><td>- FloatW&lt;RealType,p,e&gt;() </td></tr>
<tr>
<td>Float&lt;RealType,p,0&gt;() </td><td>Fixed&lt;RealType,p&gt;() </td></tr>
<tr>
<td>FloatU&lt;RealType,p,0&gt;() </td><td>FixedU&lt;RealType,p&gt;() </td></tr>
<tr>
<td>FloatN&lt;RealType,p,0&gt;() </td><td>FixedN&lt;RealType,p&gt;() </td></tr>
<tr>
<td>FloatW&lt;RealType,p,0&gt;() </td><td>FixedW&lt;RealType,p&gt;() </td></tr>
</table>
</center><p>A caution about FixedO() and FixedC(). All four of FixedS(), FixedN() - 0.5, FixedO() - 0.5, and FixedC() - 0.5 produce results which are strictly symmetric about 0 and would thus be suitable for an unbiased random walk. The variances of the first two distributions are 1/12 + O(<em>h</em><sup>2</sup>), close to the ideal value. On the other hand the variances of the distributions of FixedO() and FixedC() are 1/12 + O(<em>h</em>), significantly further from the ideal value. (In practice, using a strictly symmetric normal distribution is preferable for simulating a random walk.)</p>
<p>Similarly, consider estimating the value of pi by randomly selecting points in a unit square and determining what fraction lie in a circle of diameter 1. Sampling in the square using FixedO() or FixedC() gives poorer results than FixedN(), and FixedS() gives slightly better results.</p>
<p>Because of their definitions in terms of <em>u</em>, any of Fixed(), FixedU(), FixedN(), or FixedS() can be used to cover the periodic unit interval in an unbiased way. Thus to sample an angle uniformly, use 2 * pi * Fixed() or 2 * pi * FixedS(). The latter has the advantage that it is strictly symmetric about zero. In addition, angles which are multiples of pi/2 are avoided (which may obviate the need to check for special cases).</p>
<p>Usually, these real routines would be invoked by specifying the type and allowing the precision to be determined from the type, e.g., Real&lt;double&gt;(). However, in some cases it might be useful to specify a lower precision:</p>
<ul>
<li>to match the precision on another platform and thereby to ensure portability, e.g., Real&lt;double, 48&gt;() to match the precision of the Cray 1 computers.</li>
<li>for debugging to explore boundary cases or to allow a thorough exploration of possible results, e.g., Real&lt;real, 4&gt;().</li>
<li>to control rounding errors, e.g., 1.0 + Real&lt;double, 52&gt;() samples the doubles in [1, 2) uniformly (while 1.0 + Real&lt;double&gt;() does not).</li>
<li>for economy, e.g., Real&lt;double, 32&gt;() consumes 1 random number from RandomGenerator instead of 2. (This is the weakest reason. The overall speedup is likely to be small; and, in any case, accuracy should trump speed.)</li>
</ul>
<center> Back to <a class="el" href="integer.html">Random integers</a>. Forward to <a class="el" href="other.html">Other random results</a>. Up to <a class="el" href="index.html#contents">Contents</a>. </center> </div></div>
<hr class="footer"/><address class="footer"><small>Generated on Sat Jan 21 2012 for RandomLib by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
