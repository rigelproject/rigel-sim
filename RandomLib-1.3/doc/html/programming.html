<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RandomLib: Programming tips</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RandomLib</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Programming tips </div>  </div>
</div>
<div class="contents">
<div class="textblock"><center> Back to <a class="el" href="save.html">Saving and restoring the state</a>. Forward to <a class="el" href="parallel.html">Parallelization</a>. Up to <a class="el" href="index.html#contents">Contents</a>. </center><p>This page contains the following sections</p>
<ul>
<li><a class="el" href="programming.html#conversion">Conversion from std::rand()</a></li>
<li><a class="el" href="programming.html#stl">Interaction with the standard template library</a></li>
<li><a class="el" href="programming.html#misc">Miscellaneous</a></li>
<li><a class="el" href="programming.html#switch">Selection of default generator</a></li>
<li><a class="el" href="programming.html#timing">Timing results</a></li>
<li><a class="el" href="programming.html#checking">Checking the engines</a></li>
</ul>
<h2><a class="anchor" id="conversion"></a>
Conversion from std::rand()</h2>
<p>Here are simple steps to convert a code using rand() to Random:</p>
<ul>
<li>Change #include &lt;cstdlib&gt; to #include &lt;<a class="el" href="Random_8hpp.html" title="Header for Random, RandomGenerator.">RandomLib/Random.hpp</a>&gt;.</li>
<li>Change std::srand(unsigned int) to RandomLib::Random::Global.Reseed(unsigned long); change std::srand(time(0)) to RandomLib::Random::Global.Reseed(). (Reseed() uses a more "random" seed than the current time in seconds.)</li>
<li>As a stop-gap, change std::rand() to <a class="el" href="classRandomLib_1_1RandomCanonical.html#a708577f0b6d591de679745817b19d0cc">RandomLib::Random::Global()</a> and change RAND_MAX to RandomLib::Random::max. Preferably, you should see how std::rand() is being used and substitute the appropriate member function of Random. For example:<ul>
<li>To obtain a random real in [0,1), change double(std::rand())/(RAND_MAX + 1.0) to RandomLib::Random::Global.Fixed&lt;double&gt;().</li>
<li>To generate a random real in (0,1], to avoid a singularity at 0, use RandomLib::Random::Global.FixedU&lt;double&gt;().</li>
<li>To generate a real symmetrically distributed in (-1/2,1/2), use RandomLib::Random::Global.FixedS&lt;double&gt;().</li>
<li>To obtain a random integer in [0,n), change int(n * double(std::rand())/(RAND_MAX + 1.0)) to RandomLib::Random::Global.Integer(n).</li>
<li>To select a random integer in [m,n], use RandomLib::Random::Global.IntegerC(m,n).</li>
</ul>
</li>
<li>Change std::random_shuffle(first, last) to std::random_shuffle(first, last, <a class="el" href="classRandomLib_1_1RandomCanonical.html#a6fb9a6e2bbe736e10a0431896b8adb2f">RandomLib::Random::Global</a>).</li>
<li>Change std::generate(first, last, std::rand) to pass <a class="el" href="classRandomLib_1_1RandomCanonical.html#a6fb9a6e2bbe736e10a0431896b8adb2f">RandomLib::Random::Global</a> by reference. See section on using the <a class="el" href="programming.html#stl">standard template library</a>.</li>
</ul>
<p>These examples use Random::Global which is a globally defined Random object. In many cases this suffices. However, if different parts of your code need independent random number streams, you can create your own Random objects. In these cases, you might want to vary the seeds used to initialize the separate streams in a systematic way and, in that case, you can seed Random with a vector. When you pass Random objects to other routines you should usually (always?) pass them by reference, Random&amp;, to ensure that that the change in the state of the generator is seen by the parent routine.</p>
<h2><a class="anchor" id="stl"></a>
Interaction with the standard template library</h2>
<p>Do not pass a Random object to std::generate to fill an vector with random integers. Even though operator()() is defined to produce an random integer in [0,2<sup>32</sup>), generate makes a <em>copy</em> of its operator argument. Thus </p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomLib::Random</a> r; r.Reseed();
  std::vector&lt;unsigned&gt; a(10);
  std::vector&lt;unsigned&gt; b(10);
  std::generate(a.begin(), a.end(), r);
  std::generate(b.begin(), b.end(), r);
</pre></div><p> results in <em>a</em> and <em>b</em> having the same contents and r.Count() == 0. You should instead pass the Random object by reference as in </p>
<div class="fragment"><pre class="fragment">  std::generate&lt;std::vector&lt;unsigned&gt;::iterator, <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomLib::Random</a>&amp;&gt;
    (a.begin(), a.end(), r);
  std::generate&lt;std::vector&lt;unsigned&gt;::iterator, <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomLib::Random</a>&amp;&gt;
    (b.begin(), b.end(), r);
</pre></div><p> Alternatively (and more flexibly) you can define function objects which accept the Random by reference in the constructor as follows: </p>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> IntType = <span class="keywordtype">int</span>&gt; <span class="keyword">class </span>RandomInteger {
  <span class="keyword">private</span>:
    <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomLib::Random</a>&amp; _r;
    <span class="keyword">const</span> IntType _m, _n;
  <span class="keyword">public</span>:
    RandomInteger(<a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomLib::Random</a>&amp; r, IntType m, IntType n)
      : _r(r), _m(m), _n(n) {}
    IntType operator()() { <span class="keywordflow">return</span> _r.IntegerC&lt;IntType&gt;(_m, _n); }
  };

  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> RealType = <span class="keywordtype">double</span>&gt; <span class="keyword">class </span>RandomNormal {
  <span class="keyword">private</span>:
    <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomLib::Random</a>&amp; _r;
    <span class="keyword">const</span> <a class="code" href="classRandomLib_1_1NormalDistribution.html" title="Normal deviates.">RandomLib::NormalDistribution&lt;RealType&gt;</a> _n;
    <span class="keyword">const</span> RealType _mean, _sigma;
  <span class="keyword">public</span>:
    RandomNormal(<a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomLib::Random</a>&amp; r,
                 RealType mean = RealType(0), RealType sigma = RealType(1))
      : _r(r), _n(RandomLib::NormalDistribution&lt;RealType&gt;())
      , _mean(mean), _sigma(sigma) {}
    RealType operator()() { <span class="keywordflow">return</span> _n(_r, _mean, _sigma); }
  };
</pre></div><p> Now, you can use </p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomLib::Random</a> r; r.Reseed();
  std::vector&lt;int&gt; a(10);     <span class="comment">// Fill with integers in [-10,10]</span>
  std::generate(a.begin(), a.end(), RandomInteger&lt;&gt;(r,-10,10));
  std::vector&lt;double&gt; b(10);       <span class="comment">// Fill with normal deviates</span>
  std::generate(b.begin(), b.end(), RandomNormal&lt;&gt;(r,1.0,2.0));
</pre></div><p> C++0x offers a better way of doing this using lambda expressions. These allow you to write function objects "in line" (rather than as some small once-used class in another part of the file. See <a class="el" href="RandomLambda_8cpp.html" title="Using the STL and lambda expressions with RandomLib.">RandomLambda.cpp</a>.</p>
<p>On the other hand, std::random_shuffle does pass its operator argument by reference. Thus a vector can be shuffled with </p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomLib::Random</a> r; r.Reseed();
  std::vector&lt;unsigned&gt; a(100);
  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; 100; ++i) a[i] = i;
  <span class="comment">// create a random permutation of [0,100)</span>
  std::random_shuffle(a.begin(), a.end(), r);
</pre></div><p> This shuffles because operator()(unsigned n) is defined to produce an random integer in [0,<em>n</em>). This shuffling can result in all possible permutations of vectors of lengths up to 2000 (because 2000! &lt; 2<sup>19937</sup>), whereas the built-in random number generator (invoked when the last argument to random_shuffle is omitted) can typically only produce all the permutations of 12 or fewer objects. This method of shuffling only works if the number of elements being shuffled is less than 2^32. On 64-bit computers, this condition can be violated. In that case, use SRandom64 as the basic random number class, or else pass a function object which can accept a unsigned long long argument; for an example see <a class="el" href="RandomLambda_8cpp.html" title="Using the STL and lambda expressions with RandomLib.">RandomLambda.cpp</a>.</p>
<h2><a class="anchor" id="misc"></a>
Miscellaneous</h2>
<p>When saving the state of a program in a restart file, it is usually necessary to save only the Random objects with Save(...). (In fact, Random contains no additional state beyond the state of RandomGenerator. And thus Save just calls the underlying RandomGenerator::Save.)</p>
<p>RandomSelect has state which is derivable from its input weights. However, neither it nor the other distributions contain state which depends on the Random argument to operator()(Random&amp; r) (which is a const member function).</p>
<p>For speed and for better control over round-off errors, the real routines FixedX are preferred over FloatX. In a few cases, FloatX gives better results, e.g., in the implementation of ExponentialDistribution where it provides finer granularity in the results.</p>
<p>Fixed, FixedU, FixedN, FixedW, FixedS are all obtained by rounding an ideal uniform deviate and so can all be used to sample periodic intervals uniformly. If possible, avoid using FixedC and FixedO since they can introduce bias into your simulations. Instead of FixedC, consider FixedN. Instead of FixedO, consider FixedU (to avoid 0) or shift interval to (-1/2,1/2) and use FixedS. You can also generate results in (0,1) by invoking FixedS with a smaller precision and shifting the result, for example </p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomLib::Random</a> r; r.Reseed();
  <span class="keywordtype">double</span> y =              <span class="comment">// result in (0,1)</span>
    r.<a class="code" href="classRandomLib_1_1RandomCanonical.html#a1e033fb0517d4bea9c7ebdadf317695b">FixedS</a>&lt;double, std::numeric_limits&lt;double&gt;::digits - 1&gt;() + 0.5;
</pre></div><p>This library defines a STATIC_ASSERT to check template parameters and the values of some constants at compile time. For example, this will prevent you from requesting 100 bits of accuracy in a float, e.g., Fixed&lt;float,100&gt;(). The error message you get from the compiler may not be very informative. However if you look at the corresponding line of source code in the header file, you should be able to figure out the problem.</p>
<p>Avoid using calling RandomLib twice in one expression, e.g., </p>
<div class="fragment"><pre class="fragment">  pi = std::atan2(0.0, 1.0);
  y = std::sqrt(r.<a class="code" href="classRandomLib_1_1RandomCanonical.html#a7dde483cd76f2e4bb75d378b54c64468">Fixed</a>()) * std::sin(2 * pi * r.<a class="code" href="classRandomLib_1_1RandomCanonical.html#a1e033fb0517d4bea9c7ebdadf317695b">FixedS</a>())
</pre></div><p> because you don't know which random number will of computed first. This means that changing compilers or even just changing the optimization level might lead to large changes in your results even if the random seed is the same. In this case, you could instead use </p>
<div class="fragment"><pre class="fragment">  pi = std::atan2(0.0, 1.0);
  y = std::sqrt(r.<a class="code" href="classRandomLib_1_1RandomCanonical.html#a7dde483cd76f2e4bb75d378b54c64468">Fixed</a>());
  y *= std::sin(2 * pi * r.<a class="code" href="classRandomLib_1_1RandomCanonical.html#a1e033fb0517d4bea9c7ebdadf317695b">FixedS</a>())
</pre></div><p> Similarly replace </p>
<div class="fragment"><pre class="fragment">  std::cout &lt;&lt; <span class="stringliteral">&quot;count=&quot;</span> &lt;&lt; r.Count() &lt;&lt; <span class="stringliteral">&quot; next rv=&quot;</span> &lt;&lt; r() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
</pre></div><p> by </p>
<div class="fragment"><pre class="fragment">  std::cout &lt;&lt; <span class="stringliteral">&quot;count=&quot;</span> &lt;&lt; r.Count();
  std::cout &lt;&lt; <span class="stringliteral">&quot; next rv=&quot;</span> &lt;&lt; r() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
</pre></div><h2><a class="anchor" id="switch"></a>
Selection of default generator</h2>
<p>RandomLib provides 8 typedefs offering you easy access to 4 different random generators: </p>
<div class="fragment"><pre class="fragment">  <span class="comment">// the 32-bit version of MT19937 with SFMT19937&#39;s mixer</span>
  <span class="keyword">typedef</span> RandomEngine&lt;MT19937  &lt;Random_u32&gt;, MixerSFMT&gt; <a class="code" href="namespaceRandomLib.html#aa15d009a00b90bac54165eaefa62cc6d">MRandomGenerator32</a>;
  <span class="comment">// the 64-bit version of MT19937 with SFMT19937&#39;s mixer</span>
  <span class="keyword">typedef</span> RandomEngine&lt;MT19937  &lt;Random_u64&gt;, MixerSFMT&gt; <a class="code" href="namespaceRandomLib.html#adcec59860060add5ef8a388ae1ecfa08">MRandomGenerator64</a>;
  <span class="comment">// the 32-bit version of SFMT19937</span>
  <span class="keyword">typedef</span> RandomEngine&lt;SFMT19937&lt;Random_u32&gt;, MixerSFMT&gt; <a class="code" href="namespaceRandomLib.html#ad9ff3ad94622faf8e22f4297d709c68f">SRandomGenerator32</a>;
  <span class="comment">// the 64-bit version of SFMT19937</span>
  <span class="keyword">typedef</span> RandomEngine&lt;SFMT19937&lt;Random_u64&gt;, MixerSFMT&gt; <a class="code" href="namespaceRandomLib.html#a583140283c09f12c37b0015b6e58b4fd">SRandomGenerator64</a>;
  <span class="keyword">typedef</span> RandomCanonical&lt;MRandomGenerator32&gt; <a class="code" href="namespaceRandomLib.html#a6355af20442260696abb0db470fed2ed">MRandom32</a>;
  <span class="keyword">typedef</span> RandomCanonical&lt;MRandomGenerator64&gt; <a class="code" href="namespaceRandomLib.html#a0705a6f5ec9888e786b94ddff903df52">MRandom64</a>;
  <span class="keyword">typedef</span> RandomCanonical&lt;SRandomGenerator32&gt; <a class="code" href="namespaceRandomLib.html#a8cdda9a7d5a923884eebf2c1215fbb7c">SRandom32</a>;
  <span class="keyword">typedef</span> RandomCanonical&lt;SRandomGenerator64&gt; <a class="code" href="namespaceRandomLib.html#a48f61e51585f2c81469ee65a69074c69">SRandom64</a>; 
</pre></div><p> Thus {M,S}RandomGenerator{32,64} gives access to the 32-bit and 64-bit versions of MT19937 and SFMT19937 generators.</p>
<p>Normally, two additional typedefs are provided </p>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> SRandomGenerator32 <a class="code" href="namespaceRandomLib.html#abbc990865dcebbdbf69fe157a137cdfb">RandomGenerator</a>;
  <span class="keyword">typedef</span> RandomCanonical&lt;RandomGenerator&gt; <a class="code" href="namespaceRandomLib.html#a9fa363d3530b1c14370988abfc707231">Random</a>; 
</pre></div><p> However if the preprocessor symbol RANDOMLIB_DEFAULT_GENERATOR is defined to be one of {M,S}RandomGenerator{32,64} when compiling files that include <a class="el" href="Random_8hpp.html" title="Header for Random, RandomGenerator.">Random.hpp</a>, then RandomGenerator is defined to be this instead. This can be defined by supplying -DRANDOMLIB_DEFAULT_GENERATOR=MRandomGenerator32 on the command line for the compiler or by specifying the value when invoking make, e.g., make RANDOMLIB_DEFAULT_GENERATOR=MRandomGenerator32 RandomExample.</p>
<p>In normal use, all the functions of RandomLib should be accessed via the <a class="el" href="namespaceRandomLib.html#a9fa363d3530b1c14370988abfc707231">RandomLib::Random</a> class (or occasionally via the underlying generator <a class="el" href="namespaceRandomLib.html#abbc990865dcebbdbf69fe157a137cdfb">RandomLib::RandomGenerator</a>).</p>
<p>The SIMD-oriented Fast Mersenne Twister random number generator, <a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/index.html">SFMT19937</a> was developed in 2006 as an improvement on the <a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html">MT19937</a>. By and large these two generators have very similar properties and can be regarded as strong enough for nearly all applications. However the SFMT19937 generator does have some advantages:</p>
<ul>
<li>SFMT19937 can be implemented efficiently on a machine supporting SSE2 or AltiVec instructions.</li>
<li>SFMT19937 recovers from a state with a preponderance of 0s more quickly (this is unlikely to occur in practice).</li>
<li>SFMT19937 has better equidistribution properties. But this is unlikely to be observable.</li>
</ul>
<p>In addition, SFMT19937 adopted an improved scheme for converting the seed into the state (via MixerSFMT) and, by default, this is used for the MT19937 generator in this library. Because of these advantages, Random is typedef'ed to the SFMT19937 generator, by default.</p>
<p>The 32-bit and 64-bit versions are comparable in strength. Indeed with the SFMT19937 generator these are essentially the same (the underlying algorithm manipulates 128-bit words in both cases). For example, we have </p>
<div class="fragment"><pre class="fragment">  SRandom32 a(<span class="stringliteral">&quot;1 2 3&quot;</span>); a.StepCount(1000000);
  SRandom64 b(<span class="stringliteral">&quot;1 2 3&quot;</span>); b.StepCount(500000);
  assert(a.Ran64() == b.Ran64()); 
</pre></div><p> The implementations of these is portable across 32-bit and 64-bit architectures. Thus the choice of between these is probably best made on the basis of the speed on the target platform. A glance at the timing data in the <a class="el" href="programming.html#timing">next section</a> shows that the 64-bit versions are about the same speed on a 64-bit machine (x86_64). However on a 64-bit machine, random routines which can consume 64-bits random results in one piece, e.g., r.Integer&lt;unsigned long long&gt;() and r.Fixed&lt;double&gt;, are faster with 64-bit versions of the generator. In practice, the 32-bit versions are more likely to perform well on a wide range of CPUs. However, it's likely that the 64-bit version will be a better choice in a few years (particularly if double-precision floating point random numbers are used).</p>
<p>I recommend against mixing generators within a single code. This will merely result in a more complicated code. However, while you are experimenting with different generators, you should print out the type of generator being used, given by Name(), together with the seed. For example: </p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomLib::SRandom64</a> r;
  std::cout &lt;&lt; <span class="stringliteral">&quot;Using &quot;</span> &lt;&lt; r.Name()
            &lt;&lt; <span class="stringliteral">&quot; with seed &quot;</span> &lt;&lt; r.SeedString() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
</pre></div><p>Quick summary: stick with the default generator <a class="el" href="namespaceRandomLib.html#a8cdda9a7d5a923884eebf2c1215fbb7c">RandomLib::SRandom32</a> accessed through <a class="el" href="namespaceRandomLib.html#a9fa363d3530b1c14370988abfc707231">RandomLib::Random</a>. In certain cases, switching to the 64-bit version <a class="el" href="namespaceRandomLib.html#a48f61e51585f2c81469ee65a69074c69">RandomLib::SRandom64</a> might be advisable.</p>
<h2><a class="anchor" id="timing"></a>
Timing results</h2>
<p>The following times were obtained on a Linux system running Fedora 12, kernel version 2.6.32, and compiling with g++ version 4.4.4 with optimization flags "-O3 -funroll-loops", on an Intel system. Here <em>r</em> is a Random object, <em>n</em> is a unsigned variable with value 0 (but the compiler doesn't know its value), <em>N</em> is a large positive integer, and all times are in ns (unless another time unit is given)</p>
<center> <table class="doxtable">
<caption align="bottom">Times (ns) for various operations</caption>
<tr>
<th rowspan="2">operation </th><th colspan="2">Intel Xeon, x86_64 2.66GHz (SSE2) </th></tr>
<tr>
<th>SRandom32</th><th>SRandom64  </th></tr>
<tr>
<td>std::rand() </td><td colspan="2">10  </td></tr>
<tr>
<td>r() </td><td>2.0 </td><td>2.7  </td></tr>
<tr>
<td>r.Integer&lt;unsigned&gt;() </td><td>2.3 </td><td>2.6  </td></tr>
<tr>
<td>r.Integer&lt;unsigned long long&gt;() </td><td>4.3 </td><td>2.7  </td></tr>
<tr>
<td>r.Integer&lt;unsigned,6&gt;() </td><td>2.0 </td><td>2.9  </td></tr>
<tr>
<td>r.Integer&lt;unsigned&gt;(52u) </td><td>3.0 </td><td>3.7  </td></tr>
<tr>
<td>r.Integer&lt;unsigned&gt;(52u+n) </td><td>10 </td><td>11  </td></tr>
<tr>
<td>r.Fixed&lt;float&gt;() </td><td>3.1 </td><td>3.5  </td></tr>
<tr>
<td>r.Fixed&lt;double&gt;() </td><td>5.6 </td><td>3.4  </td></tr>
<tr>
<td>r.Float&lt;float&gt;() </td><td>17 </td><td>18  </td></tr>
<tr>
<td>r.Float&lt;double&gt;() </td><td>18 </td><td>17  </td></tr>
<tr>
<td>r.Prob&lt;float&gt;(0.28f) </td><td>9.1 </td><td>9.3  </td></tr>
<tr>
<td>r.Prob&lt;double&gt;(0.28) </td><td>8.0 </td><td>8.6  </td></tr>
<tr>
<td>NormalDistribution&lt;float&gt;()(r) </td><td>35 </td><td>35  </td></tr>
<tr>
<td>NormalDistribution&lt;double&gt;()(r) </td><td>44 </td><td>43  </td></tr>
<tr>
<td>SeedWord() </td><td colspan="2">1.1 ms  </td></tr>
<tr>
<td>SeedVector() </td><td colspan="2">19 us  </td></tr>
<tr>
<td>r.Reset(), r.SetCount(0) </td><td colspan="2">6.9 us  </td></tr>
<tr>
<td>r.StepCount(N) </td><td>0.63 N</td><td>1.3 N </td></tr>
<tr>
<td>r.StepCount(-N) </td><td>1.1 N </td><td>2.3 N </td></tr>
</table>
</center><p>These timing figures were produced by <a class="el" href="RandomTime_8cpp.html" title="Timing RandomLib.">RandomTime.cpp</a>. You should run this yourself to determine the times relevant to your system. It is easy to adapt <a class="el" href="RandomTime_8cpp.html" title="Timing RandomLib.">RandomTime.cpp</a> to produce timings for MRandom{32,64}; however on SSE2 systems, these will be noticeably slower than the SFMT19937 generators.</p>
<p>Loop unrolling is critical in the performance of, e.g., Fixed&lt;double&gt;(). If your compiler doesn't unroll the loops in Fixed&lt;RealType,p&gt;(), you can provide specializations with the loops unrolled by hand. Much of the speed of this implementation comes from extensive use of inlined procedures. This also make the timing results sensitive to the context in which Random is called. Compare the results for r.Integer&lt;unsigned&gt;(52u) (typical if drawing a card from a deck) and r.Integer&lt;unsigned&gt;(52u+n) (as typical called by std::random_shuffle). In the first case the compiler can precompute some of the variables used resulting is a much faster execution. The best way of gauging the speed is to time or to profile your own application.</p>
<p>The time quoted for r.Reset(0), r.SetCount() gives the time to reset the generator and to convert the seed to the initial state. Note that r.Reseed(...) merely stores the seed and does not update the state and r.Reset() also similarly does not reinitialize the generator state. The random generator state is produced from the seed by calling the mixer when the first random number is requested or when SetCount is called.</p>
<p>Beware of the compiler optimizing too much code away when doing timing studies. Timing this section of code </p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomLib::Random</a> r; r.Reseed();
  <span class="keyword">const</span> <span class="keywordtype">size_t</span> n = 100000000;
  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = n; i; --i) r.<a class="code" href="classRandomLib_1_1RandomCanonical.html#a7dde483cd76f2e4bb75d378b54c64468">Fixed</a>&lt;<span class="keywordtype">double</span>&gt;();
</pre></div><p> will usually result is an unrealistically short time (by up to a factor of <em>three!</em>) because the compiler skips over a lot of the computation (the tempering of the random results and all the real multiplications). You can prevent the compiler from "cheating" in this way by using the results from the timed functions. Thus </p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomLib::Random</a> r; r.Reseed();
  <span class="keyword">const</span> <span class="keywordtype">size_t</span> n = 100000000;
  <span class="keywordtype">double</span> d = 0;
  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = n; i; --i) d += r.<a class="code" href="classRandomLib_1_1RandomCanonical.html#a7dde483cd76f2e4bb75d378b54c64468">Fixed</a>&lt;<span class="keywordtype">double</span>&gt;();
  std::cout &lt;&lt; <span class="stringliteral">&quot;Sum: &quot;</span> &lt;&lt; d &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
</pre></div><p> More simply, you can store the results in a variable which is declared volatile </p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomLib::Random</a> r; r.Reseed();
  <span class="keyword">const</span> <span class="keywordtype">size_t</span> n = 100000000;
  <span class="keyword">volatile</span> <span class="keywordtype">double</span> d;
  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = n; i; --i) d = r.<a class="code" href="classRandomLib_1_1RandomCanonical.html#a7dde483cd76f2e4bb75d378b54c64468">Fixed</a>&lt;<span class="keywordtype">double</span>&gt;();
</pre></div><h2><a class="anchor" id="checking"></a>
Checking the engines</h2>
<p>The SelfTest() method of the random generators checks the that the correct results are obtained stepping the generator both forwards and backwards. This throws an exception if the an error is detected. E.g., </p>
<div class="fragment"><pre class="fragment">    RandomLib::Random::SelfTest();
</pre></div><p> <a class="el" href="RandomExample_8cpp.html" title="Simple examples of use of RandomLib.">RandomExample.cpp</a> listed in <a class="el" href="start.html">Getting started</a> includes tests of all the generators.</p>
<p>In addition, <a class="el" href="RandomCoverage_8cpp.html" title="Coverage test for RandomLib.">RandomCoverage.cpp</a> includes code to check the various generators using their authors' test cases. This checks the current implementations of MT19937 and SFMT19937 against their original implementations. (The original 64-bit implementation of MT19937 used a vector of 64-bit integers for the seed. So for this check above it is necessary to recast these as a vector of 32-bit integers,by inserting 0 elements.)</p>
<center> Back to <a class="el" href="save.html">Saving and restoring the state</a>. Forward to <a class="el" href="parallel.html">Parallelization</a>. Up to <a class="el" href="index.html#contents">Contents</a>. </center> </div></div>
<hr class="footer"/><address class="footer"><small>Generated on Sat Jan 21 2012 for RandomLib by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
