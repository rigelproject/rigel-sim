<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RandomLib: Random.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RandomLib</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_a395a18bc3e7b9f0009bd9eb5579ac51.html">src</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Random.cpp</div>  </div>
</div>
<div class="contents">
<a href="Random_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/**</span>
<a name="l00002"></a>00002 <span class="comment"> * \file Random.cpp</span>
<a name="l00003"></a>00003 <span class="comment"> * \brief Implementation code for %RandomLib</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * Copyright (c) Charles Karney (2006-2011) &lt;charles@karney.com&gt; and licensed</span>
<a name="l00006"></a>00006 <span class="comment"> * under the MIT/X11 License.  For more information, see</span>
<a name="l00007"></a>00007 <span class="comment"> * http://randomlib.sourceforge.net/</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> * \brief Code for MixerMT0, MixerMT1, MixerSFMT.</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> * MixerMT0 is adapted from MT19937 (init_by_array) and MT19937_64</span>
<a name="l00012"></a>00012 <span class="comment"> * (init_by_array64) by Makoto Matsumoto and Takuji Nishimura.  See</span>
<a name="l00013"></a>00013 <span class="comment"> * http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/CODES/mt19937ar.c and</span>
<a name="l00014"></a>00014 <span class="comment"> * http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/VERSIONS/C-LANG/mt19937-64.c</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * MixerMT1 contains modifications to MixerMT0 by Charles Karney to</span>
<a name="l00017"></a>00017 <span class="comment"> * correct defects in MixerMT0.  This is described in W. E. Brown,</span>
<a name="l00018"></a>00018 <span class="comment"> * M. Fischler, J. Kowalkowski, M. Paterno, Random Number Generation in C++0X:</span>
<a name="l00019"></a>00019 <span class="comment"> * A Comprehensive Proposal, version 3, Sept 2006, Sec. 26.4.7.1,</span>
<a name="l00020"></a>00020 <span class="comment"> * http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2079.pdf</span>
<a name="l00021"></a>00021 <span class="comment"> * This has been replaced in the C++0X proposal by MixerSFMT.</span>
<a name="l00022"></a>00022 <span class="comment"> *</span>
<a name="l00023"></a>00023 <span class="comment"> * MixerSFMT is adapted from SFMT19937&#39;s init_by_array Mutsuo Saito given in</span>
<a name="l00024"></a>00024 <span class="comment"> * http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/SFMT-src-1.2.tar.gz and</span>
<a name="l00025"></a>00025 <span class="comment"> * is part of the C++0X proposal; see P. Becker, Working Draft, Standard for</span>
<a name="l00026"></a>00026 <span class="comment"> * Programming Language C++, Oct. 2007, Sec. 26.4.7.1,</span>
<a name="l00027"></a>00027 <span class="comment"> * http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf</span>
<a name="l00028"></a>00028 <span class="comment"> *</span>
<a name="l00029"></a>00029 <span class="comment"> * The adaption to the C++ is copyright (c) Charles Karney (2006-2011)</span>
<a name="l00030"></a>00030 <span class="comment"> * &lt;charles@karney.com&gt; and licensed under the MIT/X11 License.  For more</span>
<a name="l00031"></a>00031 <span class="comment"> * information, see http://randomlib.sourceforge.net/</span>
<a name="l00032"></a>00032 <span class="comment"> *</span>
<a name="l00033"></a>00033 <span class="comment"> * \brief Code for MT19937&lt;T&gt; and SFMT19937&lt;T&gt;.</span>
<a name="l00034"></a>00034 <span class="comment"> *</span>
<a name="l00035"></a>00035 <span class="comment"> * MT19937&lt;T&gt; is adapted from MT19937 and MT19937_64 by Makoto Matsumoto and</span>
<a name="l00036"></a>00036 <span class="comment"> * Takuji Nishimura.  See</span>
<a name="l00037"></a>00037 <span class="comment"> * http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/CODES/mt19937ar.c and</span>
<a name="l00038"></a>00038 <span class="comment"> * http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/VERSIONS/C-LANG/mt19937-64.c</span>
<a name="l00039"></a>00039 <span class="comment"> *</span>
<a name="l00040"></a>00040 <span class="comment"> * The code for stepping MT19937 backwards is adapted (and simplified) from</span>
<a name="l00041"></a>00041 <span class="comment"> * revrand() by Katsumi Hagita.  See</span>
<a name="l00042"></a>00042 <span class="comment"> * http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/VERSIONS/FORTRAN/REVmt19937b.f</span>
<a name="l00043"></a>00043 <span class="comment"> *</span>
<a name="l00044"></a>00044 <span class="comment"> * SFMT19937&lt;T&gt; is adapted from SFMT19937 Mutsuo Saito given in</span>
<a name="l00045"></a>00045 <span class="comment"> * http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/M062821.pdf and</span>
<a name="l00046"></a>00046 <span class="comment"> * http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/SFMT-src-1.2.tar.gz</span>
<a name="l00047"></a>00047 <span class="comment"> *</span>
<a name="l00048"></a>00048 <span class="comment"> * The code for stepping SFMT19937 backwards is by Charles Karney.</span>
<a name="l00049"></a>00049 <span class="comment"> *</span>
<a name="l00050"></a>00050 <span class="comment"> * The adaption to the C++ is copyright (c) Charles Karney (2006-2011)</span>
<a name="l00051"></a>00051 <span class="comment"> * &lt;charles@karney.com&gt; and licensed under the MIT/X11 License.  For more</span>
<a name="l00052"></a>00052 <span class="comment"> * information, see http://randomlib.sourceforge.net/</span>
<a name="l00053"></a>00053 <span class="comment"> **********************************************************************/</span>
<a name="l00054"></a>00054 
<a name="l00055"></a><a class="code" href="Random_8cpp.html#a1d010a4a16c25542de86edac5afed598">00055</a> <span class="preprocessor">#define RANDOMLIB_RANDOM_CPP &quot;$Id: bf3e720f32caa5c42570106ee3d2fe3c6ecefd6c $&quot;</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00057"></a>00057 <span class="comment">/**</span>
<a name="l00058"></a>00058 <span class="comment"> * Let the header file know that the library is being built.</span>
<a name="l00059"></a>00059 <span class="comment"> **********************************************************************/</span>
<a name="l00060"></a><a class="code" href="Random_8cpp.html#aa53d5e0992300c79afbad65d9d13ae50">00060</a> <span class="preprocessor">#define RANDOMLIB_BUILDING_LIBRARY 1</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &lt;<a class="code" href="Random_8hpp.html" title="Header for Random, RandomGenerator.">RandomLib/Random.hpp</a>&gt;</span>
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <span class="preprocessor">#include &lt;fstream&gt;</span>              <span class="comment">// For SeedWord reading /dev/urandom</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &lt;ctime&gt;</span>                <span class="comment">// For SeedWord calling time()</span>
<a name="l00066"></a>00066 <span class="preprocessor">#include &lt;sstream&gt;</span>              <span class="comment">// For formatting in Write32/Read32</span>
<a name="l00067"></a>00067 <span class="preprocessor">#include &lt;iomanip&gt;</span>              <span class="comment">// For formatting in Write32/Read32</span>
<a name="l00068"></a>00068 <span class="preprocessor">#if !defined(_MSC_VER)</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/time.h&gt;</span>           <span class="comment">// For SeedWord calling gettimeofday</span>
<a name="l00070"></a>00070 <span class="preprocessor">#include &lt;unistd.h&gt;</span>             <span class="comment">// For SeedWord calling getpid(), gethostid()</span>
<a name="l00071"></a>00071 <span class="preprocessor">#else</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span><span class="preprocessor">#include &lt;windows.h&gt;</span>            <span class="comment">// For SeedWord calling high prec timer</span>
<a name="l00073"></a>00073 <span class="preprocessor">#include &lt;winbase.h&gt;</span>
<a name="l00074"></a>00074 <span class="preprocessor">#include &lt;process.h&gt;</span>            <span class="comment">// For SeedWord calling getpid()</span>
<a name="l00075"></a>00075 <span class="preprocessor">#define getpid _getpid</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span><span class="preprocessor">#define gmtime_r(t,g) gmtime_s(g,t)</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span>
<a name="l00079"></a>00079 <span class="preprocessor">#if defined(_MSC_VER) || defined(__CYGWIN__)</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span><span class="preprocessor">#define strtoull strtoul</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span>
<a name="l00083"></a>00083 <a class="code" href="Random_8hpp.html#af90fa899707a2ac513d5e4c76853bbf5">RCSID_DECL</a>(<a class="code" href="Random_8cpp.html#a1d010a4a16c25542de86edac5afed598">RANDOMLIB_RANDOM_CPP</a>)
<a name="l00084"></a>00084 <a class="code" href="Random_8hpp.html#af90fa899707a2ac513d5e4c76853bbf5">RCSID_DECL</a>(<a class="code" href="RandomType_8hpp.html#a22aed913b3dffc4754e0aba8ce1accf8">RANDOMLIB_RANDOMTYPE_HPP</a>)
<a name="l00085"></a>00085 <a class="code" href="Random_8hpp.html#af90fa899707a2ac513d5e4c76853bbf5">RCSID_DECL</a>(<a class="code" href="RandomSeed_8hpp.html#a7c9c3ace3f9cc6a54cd3d7e8d80f6f99">RANDOMLIB_RANDOMSEED_HPP</a>)
<a name="l00086"></a>00086 <a class="code" href="Random_8hpp.html#af90fa899707a2ac513d5e4c76853bbf5">RCSID_DECL</a>(<a class="code" href="RandomEngine_8hpp.html#ac417a131373e0903437c777c142be5a0">RANDOMLIB_RANDOMENGINE_HPP</a>)
<a name="l00087"></a>00087 <a class="code" href="Random_8hpp.html#af90fa899707a2ac513d5e4c76853bbf5">RCSID_DECL</a>(<a class="code" href="RandomMixer_8hpp.html#a59c07e9fc0515161f7d19b12b72ef933">RANDOMLIB_RANDOMMIXER_HPP</a>)
<a name="l00088"></a>00088 <a class="code" href="Random_8hpp.html#af90fa899707a2ac513d5e4c76853bbf5">RCSID_DECL</a>(<a class="code" href="RandomAlgorithm_8hpp.html#a9606364ef1f2dd23dd5b6decb396dc84">RANDOMLIB_RANDOMALGORITHM_HPP</a>)
<a name="l00089"></a>00089 <a class="code" href="Random_8hpp.html#af90fa899707a2ac513d5e4c76853bbf5">RCSID_DECL</a>(<a class="code" href="RandomPower2_8hpp.html#a6cf8ff372dbb0793e9a022156fcf2af4">RANDOMLIB_RANDOMPOWER2_HPP</a>)
<a name="l00090"></a>00090 <a class="code" href="Random_8hpp.html#af90fa899707a2ac513d5e4c76853bbf5">RCSID_DECL</a>(<a class="code" href="RandomCanonical_8hpp.html#a88874ae01d2e22dfc7c3c3e362e17afa">RANDOMLIB_RANDOMCANONICAL_HPP</a>)
<a name="l00091"></a>00091 
<a name="l00092"></a><a class="code" href="namespaceRandomLib.html">00092</a> namespace RandomLib {
<a name="l00093"></a>00093 
<a name="l00094"></a>00094   <span class="comment">// RandomType implementation</span>
<a name="l00095"></a>00095 
<a name="l00096"></a>00096   <span class="keyword">template</span>&lt;&gt;
<a name="l00097"></a><a class="code" href="classRandomLib_1_1RandomType.html#a05c06f32c80e598b836ee526a60449e3">00097</a>   <span class="keywordtype">void</span> Random_u32::Write32(std::ostream&amp; os, <span class="keywordtype">bool</span> bin, <span class="keywordtype">int</span>&amp; cnt,
<a name="l00098"></a>00098                            <a class="code" href="classRandomLib_1_1RandomType.html#a99d4e836129ffa9171bc94375ff98546">Random_u32::type</a> x) {
<a name="l00099"></a>00099     <span class="keywordflow">if</span> (bin) {
<a name="l00100"></a>00100       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[4];
<a name="l00101"></a>00101       <span class="comment">// Use network order -- most significant byte first</span>
<a name="l00102"></a>00102       buf[3] = (<span class="keywordtype">unsigned</span> char)(x);
<a name="l00103"></a>00103       buf[2] = (<span class="keywordtype">unsigned</span> char)(x &gt;&gt;= 8);
<a name="l00104"></a>00104       buf[1] = (<span class="keywordtype">unsigned</span> char)(x &gt;&gt;= 8);
<a name="l00105"></a>00105       buf[0] = (<span class="keywordtype">unsigned</span> char)(x &gt;&gt;= 8);
<a name="l00106"></a>00106       os.write(reinterpret_cast&lt;const char *&gt;(buf), 4);
<a name="l00107"></a>00107     } <span class="keywordflow">else</span> {
<a name="l00108"></a>00108       <span class="keyword">const</span> <span class="keywordtype">int</span> longsperline = 72/9;
<a name="l00109"></a>00109       <span class="comment">// Use hexadecimal to minimize storage together with stringstream to</span>
<a name="l00110"></a>00110       <span class="comment">// isolate the effect of changing the base.</span>
<a name="l00111"></a>00111       std::ostringstream str;
<a name="l00112"></a>00112       <span class="comment">// No spacing before or after</span>
<a name="l00113"></a>00113       <span class="keywordflow">if</span> (cnt &gt; 0)
<a name="l00114"></a>00114         <span class="comment">// Newline every longsperline longs</span>
<a name="l00115"></a>00115         str &lt;&lt; (cnt % longsperline ? <span class="charliteral">&#39; &#39;</span> : <span class="charliteral">&#39;\n&#39;</span>);
<a name="l00116"></a>00116       str &lt;&lt; std::hex &lt;&lt; x;
<a name="l00117"></a>00117       os &lt;&lt; str.str();
<a name="l00118"></a>00118       ++cnt;
<a name="l00119"></a>00119     }
<a name="l00120"></a>00120   }
<a name="l00121"></a>00121 
<a name="l00122"></a>00122   <span class="keyword">template</span>&lt;&gt;
<a name="l00123"></a><a class="code" href="classRandomLib_1_1RandomType.html#ad45fc16909ae4f754d453e77b8447786">00123</a>   <span class="keywordtype">void</span> Random_u32::Read32(std::istream&amp; is, <span class="keywordtype">bool</span> bin, <a class="code" href="classRandomLib_1_1RandomType.html#a99d4e836129ffa9171bc94375ff98546">Random_u32::type</a>&amp; x) {
<a name="l00124"></a>00124     <span class="keywordflow">if</span> (bin) {
<a name="l00125"></a>00125       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[4];
<a name="l00126"></a>00126       is.read(reinterpret_cast&lt;char *&gt;(buf), 4);
<a name="l00127"></a>00127       <span class="comment">// Use network order -- most significant byte first</span>
<a name="l00128"></a>00128       x = <a class="code" href="classRandomLib_1_1RandomType.html#a99d4e836129ffa9171bc94375ff98546">Random_u32::type</a>(buf[0]) &lt;&lt; 24 | <a class="code" href="classRandomLib_1_1RandomType.html#a99d4e836129ffa9171bc94375ff98546">Random_u32::type</a>(buf[1]) &lt;&lt; 16 |
<a name="l00129"></a>00129         <a class="code" href="classRandomLib_1_1RandomType.html#a99d4e836129ffa9171bc94375ff98546">Random_u32::type</a>(buf[2]) &lt;&lt; 8 | <a class="code" href="classRandomLib_1_1RandomType.html#a99d4e836129ffa9171bc94375ff98546">Random_u32::type</a>(buf[3]);
<a name="l00130"></a>00130     } <span class="keywordflow">else</span> {
<a name="l00131"></a>00131       std::string s;
<a name="l00132"></a>00132       is &gt;&gt; std::ws &gt;&gt; s;
<a name="l00133"></a>00133       <span class="comment">// Use hexadecimal to minimize storage together with stringstream to</span>
<a name="l00134"></a>00134       <span class="comment">// isolate the effect of changing the base.</span>
<a name="l00135"></a>00135       std::istringstream str(s);
<a name="l00136"></a>00136       str &gt;&gt; std::hex &gt;&gt; x;
<a name="l00137"></a>00137     }
<a name="l00138"></a>00138     x &amp;= Random_u32::mask;
<a name="l00139"></a>00139   }
<a name="l00140"></a>00140 
<a name="l00141"></a>00141   <span class="keyword">template</span>&lt;&gt;
<a name="l00142"></a>00142   <span class="keywordtype">void</span> Random_u64::Write32(std::ostream&amp; os, <span class="keywordtype">bool</span> bin, <span class="keywordtype">int</span>&amp; cnt,
<a name="l00143"></a>00143                            <a class="code" href="classRandomLib_1_1RandomType.html#a99d4e836129ffa9171bc94375ff98546">Random_u64::type</a> x) {
<a name="l00144"></a>00144     Random_u32::Write32(os, bin, cnt, Random_u32::cast(x &gt;&gt; 32));
<a name="l00145"></a>00145     Random_u32::Write32(os, bin, cnt, Random_u32::cast(x      ));
<a name="l00146"></a>00146   }
<a name="l00147"></a>00147 
<a name="l00148"></a>00148   <span class="keyword">template</span>&lt;&gt;
<a name="l00149"></a>00149   <span class="keywordtype">void</span> Random_u64::Read32(std::istream&amp; is, <span class="keywordtype">bool</span> bin, Random_u64::type&amp; x) {
<a name="l00150"></a>00150     Random_u32::type t;
<a name="l00151"></a>00151     Random_u32::Read32(is, bin, t);
<a name="l00152"></a>00152     x = Random_u64::type(t) &lt;&lt; 32;
<a name="l00153"></a>00153     Random_u32::Read32(is, bin, t);
<a name="l00154"></a>00154     x |= Random_u64::type(t);
<a name="l00155"></a>00155   }
<a name="l00156"></a>00156 
<a name="l00157"></a>00157   <span class="comment">// RandomSeed implementation</span>
<a name="l00158"></a>00158 
<a name="l00159"></a><a class="code" href="classRandomLib_1_1RandomSeed.html#a33a51e2d0230d1006253e12035f8f89a">00159</a>   <a class="code" href="classRandomLib_1_1RandomSeed.html#a3ff30fd51a54a151d5e9a017b057976e">RandomSeed::seed_type</a> RandomSeed::SeedWord() {
<a name="l00160"></a>00160     <span class="comment">// Check that the assumptions made about the capabilities of the number</span>
<a name="l00161"></a>00161     <span class="comment">// system are valid.</span>
<a name="l00162"></a>00162     <a class="code" href="Random_8hpp.html#a8f24445c1bccd69b63e365aa5d5bb129">STATIC_ASSERT</a>(std::numeric_limits&lt;seed_type&gt;::radix == 2 &amp;&amp;
<a name="l00163"></a>00163                   !std::numeric_limits&lt;seed_type&gt;::is_signed &amp;&amp;
<a name="l00164"></a>00164                   std::numeric_limits&lt;seed_type&gt;::digits &gt;= 32,
<a name="l00165"></a>00165                   <span class="stringliteral">&quot;seed_type is a bad type&quot;</span>);
<a name="l00166"></a>00166     <a class="code" href="classRandomLib_1_1RandomType.html#a99d4e836129ffa9171bc94375ff98546">u32::type</a> t = 0;
<a name="l00167"></a>00167     <span class="comment">// Linux has /dev/urandom to initialize the seed randomly.  (Use</span>
<a name="l00168"></a>00168     <span class="comment">// /dev/urandom instead of /dev/random because it does not block.)</span>
<a name="l00169"></a>00169     {
<a name="l00170"></a>00170       std::ifstream f(<span class="stringliteral">&quot;/dev/urandom&quot;</span>, std::ios::binary | std::ios::in);
<a name="l00171"></a>00171       <span class="keywordflow">if</span> (f.good()) {
<a name="l00172"></a>00172         <span class="comment">// Read 32 bits from /dev/urandom</span>
<a name="l00173"></a>00173         f.read(reinterpret_cast&lt;char *&gt;(&amp;t), <span class="keyword">sizeof</span>(t));
<a name="l00174"></a>00174       }
<a name="l00175"></a>00175     }
<a name="l00176"></a>00176     std::vector&lt;seed_type&gt; v = SeedVector();
<a name="l00177"></a>00177     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = v.size(); i--;)
<a name="l00178"></a>00178       u32::CheckSum(v[i], t);
<a name="l00179"></a>00179     <span class="keywordflow">return</span> seed_t::cast(t);
<a name="l00180"></a>00180   }
<a name="l00181"></a>00181 
<a name="l00182"></a><a class="code" href="classRandomLib_1_1RandomSeed.html#aed42f83b02c6f06b333ef44f4cc52975">00182</a>   std::vector&lt;RandomSeed::seed_type&gt; RandomSeed::SeedVector() {
<a name="l00183"></a>00183     std::vector&lt;seed_type&gt; v;
<a name="l00184"></a>00184     {
<a name="l00185"></a>00185       <span class="comment">// fine-grained timer</span>
<a name="l00186"></a>00186 <span class="preprocessor">#if !defined(_MSC_VER)</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span>      timeval tv;
<a name="l00188"></a>00188       <span class="keywordflow">if</span> (gettimeofday(&amp;tv, 0) == 0)
<a name="l00189"></a>00189         v.push_back(seed_t::cast(tv.tv_usec));
<a name="l00190"></a>00190 <span class="preprocessor">#else</span>
<a name="l00191"></a>00191 <span class="preprocessor"></span>      LARGE_INTEGER taux;
<a name="l00192"></a>00192       <span class="keywordflow">if</span> (QueryPerformanceCounter((LARGE_INTEGER *)&amp;taux)) {
<a name="l00193"></a>00193         v.push_back(seed_t::cast(taux.LowPart));
<a name="l00194"></a>00194         v.push_back(seed_t::cast(taux.HighPart));
<a name="l00195"></a>00195       }
<a name="l00196"></a>00196 <span class="preprocessor">#endif</span>
<a name="l00197"></a>00197 <span class="preprocessor"></span>    }
<a name="l00198"></a>00198     <span class="comment">// seconds</span>
<a name="l00199"></a>00199     <span class="keyword">const</span> time_t tim = std::time(0);
<a name="l00200"></a>00200     v.push_back(seed_t::cast(<a class="code" href="classRandomLib_1_1RandomSeed.html#a3ff30fd51a54a151d5e9a017b057976e">seed_type</a>(tim)));
<a name="l00201"></a>00201     <span class="comment">// PID</span>
<a name="l00202"></a>00202     v.push_back(seed_t::cast(getpid()));
<a name="l00203"></a>00203 <span class="preprocessor">#if !defined(_MSC_VER)</span>
<a name="l00204"></a>00204 <span class="preprocessor"></span>    <span class="comment">// host ID</span>
<a name="l00205"></a>00205     v.push_back(seed_t::cast(gethostid()));
<a name="l00206"></a>00206 <span class="preprocessor">#endif</span>
<a name="l00207"></a>00207 <span class="preprocessor"></span>    {
<a name="l00208"></a>00208       <span class="comment">// year</span>
<a name="l00209"></a>00209       tm gt;
<a name="l00210"></a>00210       gmtime_r(&amp;tim, &amp;gt);
<a name="l00211"></a>00211       v.push_back((<a class="code" href="classRandomLib_1_1RandomSeed.html#a3ff30fd51a54a151d5e9a017b057976e">seed_type</a>(1900) + seed_t::cast(gt.tm_year)));
<a name="l00212"></a>00212     }
<a name="l00213"></a>00213     <span class="comment">// Candidates for additional elements:</span>
<a name="l00214"></a>00214     <span class="comment">// ip address(es) of computer, thread index.</span>
<a name="l00215"></a>00215     std::transform(v.begin(), v.end(), v.begin(), seed_t::cast&lt;seed_type&gt;);
<a name="l00216"></a>00216     <span class="keywordflow">return</span> v;
<a name="l00217"></a>00217   }
<a name="l00218"></a>00218 
<a name="l00219"></a>00219   std::vector&lt;RandomSeed::seed_type&gt;
<a name="l00220"></a><a class="code" href="classRandomLib_1_1RandomSeed.html#a27d9a634ef9196f8c0660cdc7e77c5de">00220</a>   RandomSeed::StringToVector(<span class="keyword">const</span> std::string&amp; s) {
<a name="l00221"></a>00221     std::vector&lt;seed_type&gt; v(0);
<a name="l00222"></a>00222     <span class="keyword">const</span> <span class="keywordtype">char</span>* c = s.c_str();
<a name="l00223"></a>00223     <span class="keywordtype">char</span>* q;
<a name="l00224"></a>00224     std::string::size_type p = 0;
<a name="l00225"></a>00225     <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l00226"></a>00226       p = s.find_first_of(<span class="stringliteral">&quot;0123456789&quot;</span>, p);
<a name="l00227"></a>00227       <span class="keywordflow">if</span> (p == std::string::npos)
<a name="l00228"></a>00228         <span class="keywordflow">break</span>;
<a name="l00229"></a>00229       v.push_back(seed_t::cast(std::strtoull(c + p, &amp;q, 0)));
<a name="l00230"></a>00230       p = q - c;
<a name="l00231"></a>00231     }
<a name="l00232"></a>00232     <span class="keywordflow">return</span> v;
<a name="l00233"></a>00233   }
<a name="l00234"></a>00234 
<a name="l00235"></a>00235   <span class="comment">// RandomEngine implementation</span>
<a name="l00236"></a>00236 
<a name="l00237"></a>00237   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Algorithm, <span class="keyword">class</span> Mixer&gt;
<a name="l00238"></a>00238   <span class="keywordtype">void</span> <a class="code" href="classRandomLib_1_1RandomEngine.html" title="Uniform random number generator.">RandomEngine&lt;Algorithm, Mixer&gt;::Init</a>() throw() {
<a name="l00239"></a>00239     <span class="comment">// On exit we have _ptr == N.</span>
<a name="l00240"></a>00240 
<a name="l00241"></a>00241     <a class="code" href="Random_8hpp.html#a8f24445c1bccd69b63e365aa5d5bb129">STATIC_ASSERT</a>(std::numeric_limits&lt;typename mixer_t::type&gt;::radix == 2 &amp;&amp;
<a name="l00242"></a>00242                   !std::numeric_limits&lt;typename mixer_t::type&gt;::is_signed &amp;&amp;
<a name="l00243"></a>00243                   std::numeric_limits&lt;typename mixer_t::type&gt;::digits &gt;=
<a name="l00244"></a>00244                   <span class="keywordtype">int</span>(mixer_t::width),
<a name="l00245"></a>00245                   <span class="stringliteral">&quot;mixer_type is a bad type&quot;</span>);
<a name="l00246"></a>00246 
<a name="l00247"></a>00247     <a class="code" href="Random_8hpp.html#a8f24445c1bccd69b63e365aa5d5bb129">STATIC_ASSERT</a>(std::numeric_limits&lt;result_type&gt;::radix == 2 &amp;&amp;
<a name="l00248"></a>00248                   !std::numeric_limits&lt;result_type&gt;::is_signed &amp;&amp;
<a name="l00249"></a>00249                   std::numeric_limits&lt;result_type&gt;::digits &gt;= width,
<a name="l00250"></a>00250                   <span class="stringliteral">&quot;engine_type is a bad type&quot;</span>);
<a name="l00251"></a>00251 
<a name="l00252"></a>00252     <a class="code" href="Random_8hpp.html#a8f24445c1bccd69b63e365aa5d5bb129">STATIC_ASSERT</a>(mixer_t::width == 32 || mixer_t::width == 64,
<a name="l00253"></a>00253                   <span class="stringliteral">&quot;Mixer width must be 32 or 64&quot;</span>);
<a name="l00254"></a>00254 
<a name="l00255"></a>00255     <a class="code" href="Random_8hpp.html#a8f24445c1bccd69b63e365aa5d5bb129">STATIC_ASSERT</a>(width == 32 || width == 64,
<a name="l00256"></a>00256                   <span class="stringliteral">&quot;Algorithm width must be 32 or 64&quot;</span>);
<a name="l00257"></a>00257 
<a name="l00258"></a>00258     <span class="comment">// If the bit-widths are the same then the data sizes must be the same.</span>
<a name="l00259"></a>00259     <a class="code" href="Random_8hpp.html#a8f24445c1bccd69b63e365aa5d5bb129">STATIC_ASSERT</a>(!(mixer_t::width == width) ||
<a name="l00260"></a>00260                   <span class="keyword">sizeof</span>(_stateu) == <span class="keyword">sizeof</span>(_state),
<a name="l00261"></a>00261                   <span class="stringliteral">&quot;Same bit-widths but different storage&quot;</span>);
<a name="l00262"></a>00262 
<a name="l00263"></a>00263     <span class="comment">// Repacking assumes that narrower data type is at least as wasteful than</span>
<a name="l00264"></a>00264     <span class="comment">// the broader one.</span>
<a name="l00265"></a>00265     <a class="code" href="Random_8hpp.html#a8f24445c1bccd69b63e365aa5d5bb129">STATIC_ASSERT</a>(!(mixer_t::width &lt; width) ||
<a name="l00266"></a>00266                   <span class="keyword">sizeof</span>(_stateu) &gt;= <span class="keyword">sizeof</span>(_state),
<a name="l00267"></a>00267                   <span class="stringliteral">&quot;Narrow data type uses less storage&quot;</span>);
<a name="l00268"></a>00268 
<a name="l00269"></a>00269     <a class="code" href="Random_8hpp.html#a8f24445c1bccd69b63e365aa5d5bb129">STATIC_ASSERT</a>(!(mixer_t::width &gt; width) ||
<a name="l00270"></a>00270                   <span class="keyword">sizeof</span>(_stateu) &lt;= <span class="keyword">sizeof</span>(_state),
<a name="l00271"></a>00271                   <span class="stringliteral">&quot;Narrow data type uses less storage&quot;</span>);
<a name="l00272"></a>00272 
<a name="l00273"></a>00273     <span class="comment">// Require that _statev and _state are aligned since no repacking is done</span>
<a name="l00274"></a>00274     <span class="comment">// when calling Transition</span>
<a name="l00275"></a>00275     <a class="code" href="Random_8hpp.html#a8f24445c1bccd69b63e365aa5d5bb129">STATIC_ASSERT</a>(<span class="keyword">sizeof</span>(_statev) == <span class="keyword">sizeof</span>(_state),
<a name="l00276"></a>00276                   <span class="stringliteral">&quot;Storage mismatch with internal engine data type&quot;</span>);
<a name="l00277"></a>00277 
<a name="l00278"></a>00278     <span class="comment">// Convert the seed into state</span>
<a name="l00279"></a>00279     Mixer::SeedToState(_seed, _stateu, NU);
<a name="l00280"></a>00280 
<a name="l00281"></a>00281     <span class="comment">// Pack into _state</span>
<a name="l00282"></a>00282     <span class="keywordflow">if</span> (mixer_t::width &lt; width) {
<a name="l00283"></a>00283       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; N; ++i)
<a name="l00284"></a>00284         <span class="comment">// Assume 2:1 LSB packing</span>
<a name="l00285"></a>00285         _state[i] = result_type(_stateu[2*i]) |
<a name="l00286"></a>00286           result_type(_stateu[2*i + 1]) &lt;&lt;
<a name="l00287"></a>00287           (mixer_t::width &lt; width ? mixer_t::width : 0);
<a name="l00288"></a>00288     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mixer_t::width &gt; width) {
<a name="l00289"></a>00289       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = N; i--;)
<a name="l00290"></a>00290         <span class="comment">// Assume 1:2 LSB packing</span>
<a name="l00291"></a>00291         _state[i] = result_t::cast(_stateu[i&gt;&gt;1] &gt;&gt; width * (i&amp;1u));
<a name="l00292"></a>00292     } <span class="comment">// Otherwise the union takes care of it</span>
<a name="l00293"></a>00293 
<a name="l00294"></a>00294     Algorithm::NormalizeState(_state);
<a name="l00295"></a>00295 
<a name="l00296"></a>00296     _rounds = -1;
<a name="l00297"></a>00297     _ptr = N;
<a name="l00298"></a>00298   }
<a name="l00299"></a>00299 
<a name="l00300"></a>00300   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Algorithm, <span class="keyword">class</span> Mixer&gt; Random_u32::type
<a name="l00301"></a>00301   RandomEngine&lt;Algorithm, Mixer&gt;::Check(u64::type v, u32::type e,
<a name="l00302"></a>00302                                         u32::type m)<span class="keyword"> const </span>{
<a name="l00303"></a>00303     <span class="keywordflow">if</span> (v != version)
<a name="l00304"></a>00304       <span class="keywordflow">throw</span> RandomErr(Name() + <span class="stringliteral">&quot;: Unknown version&quot;</span>);
<a name="l00305"></a>00305     <span class="keywordflow">if</span> (e != Algorithm::version)
<a name="l00306"></a>00306       <span class="keywordflow">throw</span> RandomErr(Name() + <span class="stringliteral">&quot;: Algorithm mismatch&quot;</span>);
<a name="l00307"></a>00307     <span class="keywordflow">if</span> (m != Mixer::version)
<a name="l00308"></a>00308       <span class="keywordflow">throw</span> RandomErr(Name() + <span class="stringliteral">&quot;: Mixer mismatch&quot;</span>);
<a name="l00309"></a>00309     u32::type check = 0;
<a name="l00310"></a>00310     u64::CheckSum(v, check);
<a name="l00311"></a>00311     u32::CheckSum(e, check);
<a name="l00312"></a>00312     u32::CheckSum(m, check);
<a name="l00313"></a>00313     u32::CheckSum(u32::type(_seed.size()), check);
<a name="l00314"></a>00314     <span class="keywordflow">for</span> (std::vector&lt;seed_type&gt;::const_iterator n = _seed.begin();
<a name="l00315"></a>00315          n != _seed.end(); ++n) {
<a name="l00316"></a>00316       <span class="keywordflow">if</span> (*n != seed_t::cast(*n))
<a name="l00317"></a>00317         <span class="keywordflow">throw</span> RandomErr(Name() + <span class="stringliteral">&quot;: Illegal seed value&quot;</span>);
<a name="l00318"></a>00318       u32::CheckSum(u32::type(*n), check);
<a name="l00319"></a>00319     }
<a name="l00320"></a>00320     u32::CheckSum(_ptr, check);
<a name="l00321"></a>00321     <span class="keywordflow">if</span> (_stride == 0 || _stride &gt; UNINIT/2)
<a name="l00322"></a>00322       <span class="keywordflow">throw</span> RandomErr(Name() + <span class="stringliteral">&quot;: Invalid stride&quot;</span>);
<a name="l00323"></a>00323     u32::CheckSum(_stride, check);
<a name="l00324"></a>00324     <span class="keywordflow">if</span> (_ptr != UNINIT) {
<a name="l00325"></a>00325       <span class="keywordflow">if</span> (_ptr &gt;= N + _stride)
<a name="l00326"></a>00326         <span class="keywordflow">throw</span> RandomErr(Name() + <span class="stringliteral">&quot;: Invalid pointer&quot;</span>);
<a name="l00327"></a>00327       u64::CheckSum(_rounds, check);
<a name="l00328"></a>00328       Algorithm::CheckState(_state, check);
<a name="l00329"></a>00329     }
<a name="l00330"></a>00330     <span class="keywordflow">return</span> check;
<a name="l00331"></a>00331   }
<a name="l00332"></a>00332 
<a name="l00333"></a>00333   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Algorithm, <span class="keyword">typename</span> Mixer&gt;
<a name="l00334"></a>00334   RandomEngine&lt;Algorithm, Mixer&gt;::RandomEngine(std::istream&amp; is, <span class="keywordtype">bool</span> bin) {
<a name="l00335"></a>00335     u64::type versionr;
<a name="l00336"></a>00336     u32::type versione, versionm, t;
<a name="l00337"></a>00337     u64::Read32(is, bin, versionr);
<a name="l00338"></a>00338     u32::Read32(is, bin, versione);
<a name="l00339"></a>00339     u32::Read32(is, bin, versionm);
<a name="l00340"></a>00340     u32::Read32(is, bin, t);
<a name="l00341"></a>00341     _seed.resize(<span class="keywordtype">size_t</span>(t));
<a name="l00342"></a>00342     <span class="keywordflow">for</span> (std::vector&lt;seed_type&gt;::iterator n = _seed.begin();
<a name="l00343"></a>00343          n != _seed.end(); ++n) {
<a name="l00344"></a>00344       u32::Read32(is, bin, t);
<a name="l00345"></a>00345       *n = seed_type(t);
<a name="l00346"></a>00346     }
<a name="l00347"></a>00347     u32::Read32(is, bin, t);
<a name="l00348"></a>00348     <span class="comment">// Don&#39;t need to worry about sign extension because _ptr is unsigned.</span>
<a name="l00349"></a>00349     _ptr = unsigned(t);
<a name="l00350"></a>00350     u32::Read32(is, bin, t);
<a name="l00351"></a>00351     _stride = unsigned(t);
<a name="l00352"></a>00352     <span class="keywordflow">if</span> (_ptr != UNINIT) {
<a name="l00353"></a>00353       u64::type p;
<a name="l00354"></a>00354       u64::Read32(is, bin, p);
<a name="l00355"></a>00355       _rounds = (<span class="keywordtype">long</span> long)(p);
<a name="l00356"></a>00356       <span class="comment">// Sign extension in case long long is bigger than 64 bits.</span>
<a name="l00357"></a>00357       _rounds &lt;&lt;= 63 - std::numeric_limits&lt;long long&gt;::digits;
<a name="l00358"></a>00358       _rounds &gt;&gt;= 63 - std::numeric_limits&lt;long long&gt;::digits;
<a name="l00359"></a>00359       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; N; ++i)
<a name="l00360"></a>00360         result_t::Read32(is, bin, _state[i]);
<a name="l00361"></a>00361     }
<a name="l00362"></a>00362     u32::Read32(is, bin, t);
<a name="l00363"></a>00363     <span class="keywordflow">if</span> (t != Check(versionr, versione, versionm))
<a name="l00364"></a>00364       <span class="keywordflow">throw</span> RandomErr(Name() + <span class="stringliteral">&quot;: Checksum failure&quot;</span>);
<a name="l00365"></a>00365   }
<a name="l00366"></a>00366 
<a name="l00367"></a>00367   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Algorithm, <span class="keyword">typename</span> Mixer&gt;
<a name="l00368"></a><a class="code" href="classRandomLib_1_1RandomEngine.html#a3bbc089676bf9e1a3eac60837d5d06fe">00368</a>   <span class="keywordtype">void</span> <a class="code" href="classRandomLib_1_1RandomEngine.html" title="Uniform random number generator.">RandomEngine&lt;Algorithm, Mixer&gt;::Save</a>(std::ostream&amp; os,
<a name="l00369"></a>00369                                             <span class="keywordtype">bool</span> bin)<span class="keyword"> const </span>{
<a name="l00370"></a>00370     <a class="code" href="classRandomLib_1_1RandomType.html#a99d4e836129ffa9171bc94375ff98546">u32::type</a> check = Check(version, Algorithm::version, Mixer::version);
<a name="l00371"></a>00371     <span class="keywordtype">int</span> c = 0;
<a name="l00372"></a>00372     u64::Write32(os, bin, c, version);
<a name="l00373"></a>00373     u32::Write32(os, bin, c, Algorithm::version);
<a name="l00374"></a>00374     u32::Write32(os, bin, c, Mixer::version);
<a name="l00375"></a>00375     u32::Write32(os, bin, c, <a class="code" href="classRandomLib_1_1RandomType.html#a99d4e836129ffa9171bc94375ff98546">u32::type</a>(_seed.size()));
<a name="l00376"></a>00376     <span class="keywordflow">for</span> (std::vector&lt;seed_type&gt;::const_iterator n = _seed.begin();
<a name="l00377"></a>00377          n != _seed.end(); ++n)
<a name="l00378"></a>00378       u32::Write32(os, bin, c, <a class="code" href="classRandomLib_1_1RandomType.html#a99d4e836129ffa9171bc94375ff98546">u32::type</a>(*n));
<a name="l00379"></a>00379     u32::Write32(os, bin, c, _ptr);
<a name="l00380"></a>00380     u32::Write32(os, bin, c, _stride);
<a name="l00381"></a>00381     <span class="keywordflow">if</span> (_ptr != UNINIT) {
<a name="l00382"></a>00382       u64::Write32(os, bin, c, u64::type(_rounds));
<a name="l00383"></a>00383       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; N; ++i)
<a name="l00384"></a>00384         result_t::Write32(os, bin, c, _state[i]);
<a name="l00385"></a>00385     }
<a name="l00386"></a>00386     u32::Write32(os, bin, c, check);
<a name="l00387"></a>00387   }
<a name="l00388"></a>00388 
<a name="l00389"></a>00389   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Algorithm, <span class="keyword">typename</span> Mixer&gt;
<a name="l00390"></a><a class="code" href="classRandomLib_1_1RandomEngine.html#a88b6807b16f97336a16784db2141ac28">00390</a>   <span class="keywordtype">void</span> <a class="code" href="classRandomLib_1_1RandomEngine.html" title="Uniform random number generator.">RandomEngine&lt;Algorithm, Mixer&gt;::StepCount</a>(<span class="keywordtype">long</span> <span class="keywordtype">long</span> n) <span class="keywordflow">throw</span>() {
<a name="l00391"></a>00391     <span class="comment">// On exit we have 0 &lt;= _ptr &lt;= N.</span>
<a name="l00392"></a>00392     <span class="keywordflow">if</span> (_ptr == UNINIT)
<a name="l00393"></a>00393       Init();
<a name="l00394"></a>00394     <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> ncount = n + Count(); <span class="comment">// new Count()</span>
<a name="l00395"></a>00395     <span class="keywordtype">long</span> <span class="keywordtype">long</span> nrounds = ncount / N;
<a name="l00396"></a>00396     <span class="keywordtype">int</span> nptr = int(ncount - nrounds * N);
<a name="l00397"></a>00397     <span class="comment">// We pick _ptr = N or _ptr = 0 depending on which choice involves the</span>
<a name="l00398"></a>00398     <span class="comment">// least work.  We thus avoid doing one (potentially unneeded) call to</span>
<a name="l00399"></a>00399     <span class="comment">// Transition.</span>
<a name="l00400"></a>00400     <span class="keywordflow">if</span> (nptr &lt; 0) {
<a name="l00401"></a>00401       --nrounds;
<a name="l00402"></a>00402       nptr += N;
<a name="l00403"></a>00403     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nptr == 0 &amp;&amp; nrounds &gt; _rounds) {
<a name="l00404"></a>00404       nptr = N;
<a name="l00405"></a>00405       --nrounds;
<a name="l00406"></a>00406     }
<a name="l00407"></a>00407     <span class="keywordflow">if</span> (nrounds != _rounds)
<a name="l00408"></a>00408       Algorithm::Transition(nrounds - _rounds, _statev);
<a name="l00409"></a>00409     _rounds = nrounds;
<a name="l00410"></a>00410     _ptr = nptr;
<a name="l00411"></a>00411   }
<a name="l00412"></a>00412 
<a name="l00413"></a>00413   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Algorithm, <span class="keyword">typename</span> Mixer&gt;
<a name="l00414"></a><a class="code" href="classRandomLib_1_1RandomEngine.html#ae0d75d5f422b1298866722fcac7281a3">00414</a>   <span class="keywordtype">void</span> <a class="code" href="classRandomLib_1_1RandomEngine.html" title="Uniform random number generator.">RandomEngine&lt;Algorithm, Mixer&gt;::SelfTest</a>() {
<a name="l00415"></a>00415     <a class="code" href="classRandomLib_1_1RandomEngine.html" title="Uniform random number generator.">RandomEngine</a> g(std::vector&lt;seed_type&gt;(0));
<a name="l00416"></a>00416     g.<a class="code" href="classRandomLib_1_1RandomEngine.html#a7770e1d3cf76fc0ef405415e7fdb5c25">SetCount</a>(10000-1);
<a name="l00417"></a>00417     <a class="code" href="classRandomLib_1_1RandomEngine.html#abb833157953aea2eca11d82c1a5099b9">result_type</a> x = g();
<a name="l00418"></a>00418     <span class="keywordflow">if</span> (SelfTestResult(0) &amp;&amp; x != SelfTestResult(1))
<a name="l00419"></a>00419       <span class="keywordflow">throw</span> <a class="code" href="classRandomLib_1_1RandomErr.html" title="Exception handling for RandomLib.">RandomErr</a>(Name() + <span class="stringliteral">&quot;: Incorrect result with seed &quot;</span> +
<a name="l00420"></a>00420                       g.<a class="code" href="classRandomLib_1_1RandomSeed.html#adf691e5d85c3d0e037244d7865157c40">SeedString</a>());
<a name="l00421"></a>00421     <a class="code" href="classRandomLib_1_1RandomSeed.html#a3ff30fd51a54a151d5e9a017b057976e">seed_type</a> s[] = {0x1234U, 0x5678U, 0x9abcU, 0xdef0U};
<a name="l00422"></a>00422     <span class="comment">//    seed_type s[] = {1, 2, 3, 4};</span>
<a name="l00423"></a>00423     g.<a class="code" href="classRandomLib_1_1RandomSeed.html#a22d741d1429cfd8a41a4157117757033">Reseed</a>(s, s+4);
<a name="l00424"></a>00424     g.<a class="code" href="classRandomLib_1_1RandomEngine.html#a88b6807b16f97336a16784db2141ac28">StepCount</a>(-20000);
<a name="l00425"></a>00425     std::string save;
<a name="l00426"></a>00426     {
<a name="l00427"></a>00427       std::ostringstream stream;
<a name="l00428"></a>00428       stream &lt;&lt; g &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00429"></a>00429       save = stream.str();
<a name="l00430"></a>00430     }
<a name="l00431"></a>00431     g.<a class="code" href="classRandomLib_1_1RandomEngine.html#a47ff255d8bf57262a8f3dbc94a8b9a89">Reset</a>();
<a name="l00432"></a>00432     {
<a name="l00433"></a>00433       std::istringstream stream(save);
<a name="l00434"></a>00434       stream &gt;&gt; g;
<a name="l00435"></a>00435     }
<a name="l00436"></a>00436     g.<a class="code" href="classRandomLib_1_1RandomEngine.html#a7770e1d3cf76fc0ef405415e7fdb5c25">SetCount</a>(10000);
<a name="l00437"></a>00437     {
<a name="l00438"></a>00438       std::ostringstream stream;
<a name="l00439"></a>00439       g.<a class="code" href="classRandomLib_1_1RandomEngine.html#a3bbc089676bf9e1a3eac60837d5d06fe">Save</a>(stream, <span class="keyword">true</span>);
<a name="l00440"></a>00440       save = stream.str();
<a name="l00441"></a>00441     }
<a name="l00442"></a>00442     {
<a name="l00443"></a>00443       std::istringstream stream(save);
<a name="l00444"></a>00444       <a class="code" href="classRandomLib_1_1RandomEngine.html" title="Uniform random number generator.">RandomEngine</a> h(std::vector&lt;seed_type&gt;(0));
<a name="l00445"></a>00445       h.<a class="code" href="classRandomLib_1_1RandomEngine.html#acd071ad41fca4e4dc0ee66fc53929669">Load</a>(stream, <span class="keyword">true</span>);
<a name="l00446"></a>00446       h.<a class="code" href="classRandomLib_1_1RandomEngine.html#a7770e1d3cf76fc0ef405415e7fdb5c25">SetCount</a>(1000000-1);
<a name="l00447"></a>00447       x = h();
<a name="l00448"></a>00448       <span class="keywordflow">if</span> (SelfTestResult(0) &amp;&amp; x != SelfTestResult(2))
<a name="l00449"></a>00449         <span class="keywordflow">throw</span> <a class="code" href="classRandomLib_1_1RandomErr.html" title="Exception handling for RandomLib.">RandomErr</a>(Name() + <span class="stringliteral">&quot;: Incorrect result with seed &quot;</span> +
<a name="l00450"></a>00450                         h.<a class="code" href="classRandomLib_1_1RandomSeed.html#adf691e5d85c3d0e037244d7865157c40">SeedString</a>());
<a name="l00451"></a>00451       g.<a class="code" href="classRandomLib_1_1RandomEngine.html#a7770e1d3cf76fc0ef405415e7fdb5c25">SetCount</a>(1000000);
<a name="l00452"></a>00452       <span class="keywordflow">if</span> (h != g)
<a name="l00453"></a>00453         <span class="keywordflow">throw</span> <a class="code" href="classRandomLib_1_1RandomErr.html" title="Exception handling for RandomLib.">RandomErr</a>(Name() + <span class="stringliteral">&quot;: Comparison failure&quot;</span>);
<a name="l00454"></a>00454     }
<a name="l00455"></a>00455   }
<a name="l00456"></a>00456 
<a name="l00457"></a>00457   <span class="keyword">template</span>&lt;&gt; <a class="code" href="classRandomLib_1_1RandomType.html#a99d4e836129ffa9171bc94375ff98546">Random_u32::type</a>
<a name="l00458"></a>00458   <a class="code" href="classRandomLib_1_1RandomEngine.html" title="Uniform random number generator.">RandomEngine&lt;MT19937&lt;Random_u32&gt;</a>, <a class="code" href="classRandomLib_1_1MixerMT0.html" title="The original MT19937 mixing functionality.">MixerMT0&lt;Random_u32&gt;</a> &gt;::
<a name="l00459"></a>00459   SelfTestResult(<span class="keywordtype">unsigned</span> i) <span class="keywordflow">throw</span>() {
<a name="l00460"></a>00460     <span class="keywordflow">return</span> i == 0 ? 1 :
<a name="l00461"></a>00461       i == 1 ? 4123659995UL : 3016432305UL;
<a name="l00462"></a>00462   }
<a name="l00463"></a>00463 
<a name="l00464"></a>00464   <span class="keyword">template</span>&lt;&gt; Random_u64::type
<a name="l00465"></a>00465   RandomEngine&lt;MT19937&lt;Random_u64&gt;, MixerMT0&lt;Random_u64&gt; &gt;::
<a name="l00466"></a>00466   SelfTestResult(<span class="keywordtype">unsigned</span> i) <span class="keywordflow">throw</span>() {
<a name="l00467"></a>00467     <span class="keywordflow">return</span> i == 0 ? 1 :
<a name="l00468"></a>00468       i == 1 ? 9981545732273789042ULL : 1384037754719008581ULL;
<a name="l00469"></a>00469   }
<a name="l00470"></a>00470 
<a name="l00471"></a>00471   <span class="keyword">template</span>&lt;&gt; Random_u32::type
<a name="l00472"></a>00472   RandomEngine&lt;MT19937&lt;Random_u32&gt;, MixerMT1&lt;Random_u32&gt; &gt;::
<a name="l00473"></a>00473   SelfTestResult(<span class="keywordtype">unsigned</span> i) <span class="keywordflow">throw</span>() {
<a name="l00474"></a>00474     <span class="keywordflow">return</span> i == 0 ? 1 :
<a name="l00475"></a>00475       i == 1 ? 4123659995UL : 2924523180UL;
<a name="l00476"></a>00476   }
<a name="l00477"></a>00477 
<a name="l00478"></a>00478   <span class="keyword">template</span>&lt;&gt; Random_u64::type
<a name="l00479"></a>00479   RandomEngine&lt;MT19937&lt;Random_u64&gt;, MixerMT1&lt;Random_u64&gt; &gt;::
<a name="l00480"></a>00480   SelfTestResult(<span class="keywordtype">unsigned</span> i) <span class="keywordflow">throw</span>() {
<a name="l00481"></a>00481     <span class="keywordflow">return</span> i == 0 ? 1 :
<a name="l00482"></a>00482       i == 1 ? 9981545732273789042ULL : 5481486777409645478ULL;
<a name="l00483"></a>00483   }
<a name="l00484"></a>00484 
<a name="l00485"></a>00485   <span class="keyword">template</span>&lt;&gt; Random_u32::type
<a name="l00486"></a>00486   RandomEngine&lt;MT19937&lt;Random_u32&gt;, MixerSFMT&gt;::
<a name="l00487"></a>00487   SelfTestResult(<span class="keywordtype">unsigned</span> i) <span class="keywordflow">throw</span>() {
<a name="l00488"></a>00488     <span class="keywordflow">return</span> i == 0 ? 1 :
<a name="l00489"></a>00489       i == 1 ? 666528879UL : 2183745132UL;
<a name="l00490"></a>00490   }
<a name="l00491"></a>00491 
<a name="l00492"></a>00492   <span class="keyword">template</span>&lt;&gt; Random_u64::type
<a name="l00493"></a>00493   RandomEngine&lt;MT19937&lt;Random_u64&gt;, MixerSFMT&gt;::
<a name="l00494"></a>00494   SelfTestResult(<span class="keywordtype">unsigned</span> i) <span class="keywordflow">throw</span>() {
<a name="l00495"></a>00495     <span class="keywordflow">return</span> i == 0 ? 1 :
<a name="l00496"></a>00496       i == 1 ? 12176471137395770412ULL : 66914054428611861ULL;
<a name="l00497"></a>00497   }
<a name="l00498"></a>00498 
<a name="l00499"></a>00499   <span class="keyword">template</span>&lt;&gt; Random_u32::type
<a name="l00500"></a>00500   RandomEngine&lt;SFMT19937&lt;Random_u32&gt;, MixerSFMT&gt;::
<a name="l00501"></a>00501   SelfTestResult(<span class="keywordtype">unsigned</span> i) <span class="keywordflow">throw</span>() {
<a name="l00502"></a>00502     <span class="keywordflow">return</span> i == 0 ? 1 :
<a name="l00503"></a>00503       i == 1 ? 2695024307UL : 782200760UL;
<a name="l00504"></a>00504   }
<a name="l00505"></a>00505 
<a name="l00506"></a>00506   <span class="keyword">template</span>&lt;&gt; Random_u64::type
<a name="l00507"></a>00507   RandomEngine&lt;SFMT19937&lt;Random_u64&gt;, MixerSFMT&gt;::
<a name="l00508"></a>00508   SelfTestResult(<span class="keywordtype">unsigned</span> i) <span class="keywordflow">throw</span>() {
<a name="l00509"></a>00509     <span class="keywordflow">return</span> i == 0 ? 1 :
<a name="l00510"></a>00510       i == 1 ? 1464461649847485149ULL : 5050640804923595109ULL;
<a name="l00511"></a>00511   }
<a name="l00512"></a>00512 
<a name="l00513"></a>00513   <span class="comment">// RandomMixer implementation</span>
<a name="l00514"></a>00514 
<a name="l00515"></a>00515   <span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomType&gt; <span class="keywordtype">void</span> MixerMT0&lt;RandomType&gt;::
<a name="l00516"></a><a class="code" href="classRandomLib_1_1MixerMT0.html#a60b123a0cd8f48346e7cf059bcedc87b">00516</a>   SeedToState(<span class="keyword">const</span> std::vector&lt;RandomSeed::seed_type&gt;&amp; seed,
<a name="l00517"></a>00517               mixer_type state[], <span class="keywordtype">unsigned</span> n) <span class="keywordflow">throw</span>() {
<a name="l00518"></a>00518     <span class="comment">// Adapted from</span>
<a name="l00519"></a>00519     <span class="comment">// http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/CODES/mt19937ar.c</span>
<a name="l00520"></a>00520     <span class="comment">// http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/VERSIONS/C-LANG/mt19937-64.c</span>
<a name="l00521"></a>00521     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> s = unsigned(seed.size());
<a name="l00522"></a>00522     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> w = mixer_t::width;
<a name="l00523"></a>00523 
<a name="l00524"></a>00524     mixer_type r = s ? a1 : a0;
<a name="l00525"></a>00525     state[0] = r;
<a name="l00526"></a>00526     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 1; k &lt; n; ++k) {
<a name="l00527"></a>00527       r = b * (r ^ r &gt;&gt; (w - 2)) + k;
<a name="l00528"></a>00528       r &amp;= mask;
<a name="l00529"></a>00529       state[k] = r;
<a name="l00530"></a>00530     }
<a name="l00531"></a>00531     <span class="keywordflow">if</span> (s &gt; 0) {
<a name="l00532"></a>00532       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> m = mixer_t::width / 32,
<a name="l00533"></a>00533         s2 = (s + m - 1)/m;
<a name="l00534"></a>00534       <span class="keywordtype">unsigned</span> i1 = 1;
<a name="l00535"></a>00535       r = state[0];
<a name="l00536"></a>00536       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = (n &gt; s2 ? n : s2), j = 0;
<a name="l00537"></a>00537            k; --k, i1 = i1 == n - 1 ? 1 : i1 + 1, <span class="comment">// i1 = i1 + 1 mod n - 1</span>
<a name="l00538"></a>00538              j = j == s2 - 1 ? 0 : j + 1 ) {      <span class="comment">// j = j+1 mod s2</span>
<a name="l00539"></a>00539         r = state[i1] ^ c * (r ^ r &gt;&gt; (w - 2));
<a name="l00540"></a>00540         r += j + mixer_type(seed[m * j]) +
<a name="l00541"></a>00541           (m == 1 || 2 * j + 1 == s ? mixer_type(0) :
<a name="l00542"></a>00542            mixer_type(seed[m * j + 1]) &lt;&lt; (w - 32));
<a name="l00543"></a>00543         r &amp;= mask;
<a name="l00544"></a>00544         state[i1] = r;
<a name="l00545"></a>00545       }
<a name="l00546"></a>00546       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = n - 1; k; --k,
<a name="l00547"></a>00547              i1 = i1 == n - 1 ? 1 : i1 + 1) { <span class="comment">// i1 = i1 + 1 mod n - 1</span>
<a name="l00548"></a>00548         r = state[i1] ^ d * (r ^ r &gt;&gt; (w - 2));
<a name="l00549"></a>00549         r -= i1;
<a name="l00550"></a>00550         r &amp;= mask;
<a name="l00551"></a>00551         state[i1] = r;
<a name="l00552"></a>00552       }
<a name="l00553"></a>00553       state[0] = <span class="keyword">typename</span> <a class="code" href="classRandomLib_1_1RandomType.html#a99d4e836129ffa9171bc94375ff98546">mixer_t::type</a>(1) &lt;&lt; (w - 1);
<a name="l00554"></a>00554     }
<a name="l00555"></a>00555   }
<a name="l00556"></a>00556 
<a name="l00557"></a>00557   <span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomType&gt; <span class="keywordtype">void</span> <a class="code" href="classRandomLib_1_1MixerMT1.html" title="The modified MT19937 mixing functionality.">MixerMT1&lt;RandomType&gt;::</a>
<a name="l00558"></a><a class="code" href="classRandomLib_1_1MixerMT1.html#a157c69869ff243eb3b80fc64a837a259">00558</a> <a class="code" href="classRandomLib_1_1MixerMT1.html" title="The modified MT19937 mixing functionality.">  SeedToState</a>(<span class="keyword">const</span> std::vector&lt;RandomSeed::seed_type&gt;&amp; seed,
<a name="l00559"></a>00559               mixer_type state[], <span class="keywordtype">unsigned</span> n) <span class="keywordflow">throw</span>() {
<a name="l00560"></a>00560     <span class="comment">// This is the algorithm given in the seed_seq class described in</span>
<a name="l00561"></a>00561     <span class="comment">// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2079.pdf It is</span>
<a name="l00562"></a>00562     <span class="comment">// a modification of</span>
<a name="l00563"></a>00563     <span class="comment">// http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/CODES/mt19937ar.c</span>
<a name="l00564"></a>00564     <span class="comment">// http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/VERSIONS/C-LANG/mt19937-64.c</span>
<a name="l00565"></a>00565     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> s = unsigned(seed.size());
<a name="l00566"></a>00566     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> w = mixer_t::width;
<a name="l00567"></a>00567 
<a name="l00568"></a>00568     mixer_type r = (a + s) &amp; mask;
<a name="l00569"></a>00569     state[0] = r;
<a name="l00570"></a>00570     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 1; k &lt; n; ++k) {
<a name="l00571"></a>00571       r = b * (r ^ r &gt;&gt; (w - 2)) + k;
<a name="l00572"></a>00572       r &amp;= mask;
<a name="l00573"></a>00573       state[k] = r;
<a name="l00574"></a>00574     }
<a name="l00575"></a>00575     <span class="keywordflow">if</span> (s &gt; 0) {
<a name="l00576"></a>00576       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> m = mixer_t::width / 32,
<a name="l00577"></a>00577         s2 = (s + m - 1)/m;
<a name="l00578"></a>00578       <span class="keywordtype">unsigned</span> i1 = 0;
<a name="l00579"></a>00579       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = (n &gt; s2 ? n : s2), j = 0;
<a name="l00580"></a>00580            k; --k, i1 = i1 == n - 1 ? 0 : i1 + 1, <span class="comment">// i1 = i1 + 1 mod n</span>
<a name="l00581"></a>00581              j = j == s2 - 1 ? 0 : j + 1 ) {      <span class="comment">// j = j+1 mod s2</span>
<a name="l00582"></a>00582         r = state[i1] ^ c * (r ^ r &gt;&gt; (w - 2));
<a name="l00583"></a>00583         r += j + mixer_type(seed[m * j]) +
<a name="l00584"></a>00584           (m == 1 || 2 * j + 1 == s ? mixer_type(0) :
<a name="l00585"></a>00585            mixer_type(seed[m * j + 1]) &lt;&lt; (w - 32));
<a name="l00586"></a>00586         r &amp;= mask;
<a name="l00587"></a>00587         state[i1] = r;
<a name="l00588"></a>00588       }
<a name="l00589"></a>00589       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = n; k; --k,
<a name="l00590"></a>00590              i1 = i1 == n - 1 ? 0 : i1 + 1) { <span class="comment">// i1 = i1 + 1 mod n</span>
<a name="l00591"></a>00591         r = state[i1] ^ d * (r ^ r &gt;&gt; (w - 2));
<a name="l00592"></a>00592         r -= i1;
<a name="l00593"></a>00593         r &amp;= mask;
<a name="l00594"></a>00594         state[i1] = r;
<a name="l00595"></a>00595       }
<a name="l00596"></a>00596     }
<a name="l00597"></a>00597   }
<a name="l00598"></a>00598 
<a name="l00599"></a><a class="code" href="classRandomLib_1_1MixerSFMT.html#a9e27b7866c9af317676c3cce99d10a29">00599</a>   <span class="keywordtype">void</span> MixerSFMT::SeedToState(<span class="keyword">const</span> std::vector&lt;RandomSeed::seed_type&gt;&amp; seed,
<a name="l00600"></a>00600                               mixer_type state[], <span class="keywordtype">unsigned</span> n) <span class="keywordflow">throw</span>() {
<a name="l00601"></a>00601     <span class="comment">// This is adapted from the routine init_by_array by Mutsuo Saito given in</span>
<a name="l00602"></a>00602     <span class="comment">// http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/SFMT-src-1.2.tar.gz</span>
<a name="l00603"></a>00603 
<a name="l00604"></a>00604     <span class="keywordflow">if</span> (n == 0)
<a name="l00605"></a>00605       <span class="keywordflow">return</span>;                   <span class="comment">// Nothing to do</span>
<a name="l00606"></a>00606 
<a name="l00607"></a>00607     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> s = unsigned(seed.size()),
<a name="l00608"></a>00608       <span class="comment">// Add treatment of small n with lag = (n - 1)/2 for n &lt;= 7.  In</span>
<a name="l00609"></a>00609       <span class="comment">// particular, the first operation (xor or plus) in each for loop</span>
<a name="l00610"></a>00610       <span class="comment">// involves three distinct indices for n &gt; 2.</span>
<a name="l00611"></a>00611       lag = n &gt;= 623 ? 11 : (n &gt;= 68 ? 7 : (n &gt;= 39 ? 5 :
<a name="l00612"></a>00612                                             (n &gt;= 7 ? 3 : (n - 1)/2))),
<a name="l00613"></a>00613       <span class="comment">// count = max( s + 1, n )</span>
<a name="l00614"></a>00614       count = s + 1 &gt; n ? s + 1 : n;
<a name="l00615"></a>00615 
<a name="l00616"></a>00616     std::fill(state, state + n, mixer_type(a));
<a name="l00617"></a>00617     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> w = mixer_t::width;
<a name="l00618"></a>00618 
<a name="l00619"></a>00619     <span class="keywordtype">unsigned</span> i = 0, k = (n - lag) / 2, l = k + lag;
<a name="l00620"></a>00620     mixer_type r = state[n - 1];
<a name="l00621"></a>00621     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; count; ++j,
<a name="l00622"></a>00622            i = i == n - 1 ? 0 : i + 1,
<a name="l00623"></a>00623            k = k == n - 1 ? 0 : k + 1,
<a name="l00624"></a>00624            l = l == n - 1 ? 0 : l + 1) {
<a name="l00625"></a>00625       <span class="comment">// Here r = state[(j - 1) mod n]</span>
<a name="l00626"></a>00626       <span class="comment">//      i = j mod n</span>
<a name="l00627"></a>00627       <span class="comment">//      k = (j + (n - lag)/2) mod n</span>
<a name="l00628"></a>00628       <span class="comment">//      l = (j + (n - lag)/2 + lag) mod n</span>
<a name="l00629"></a>00629       r ^= state[i] ^ state[k];
<a name="l00630"></a>00630       r &amp;= mask;
<a name="l00631"></a>00631       r = b * (r ^ r &gt;&gt; (w - 5));
<a name="l00632"></a>00632       state[k] += r;
<a name="l00633"></a>00633       r += i + (j &gt; s ? 0 : (j ? mixer_type(seed[j - 1]) : s));
<a name="l00634"></a>00634       state[l] += r;
<a name="l00635"></a>00635       state[i] = r;
<a name="l00636"></a>00636     }
<a name="l00637"></a>00637 
<a name="l00638"></a>00638     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = n; j; --j,
<a name="l00639"></a>00639            i = i == n - 1 ? 0 : i + 1,
<a name="l00640"></a>00640            k = k == n - 1 ? 0 : k + 1,
<a name="l00641"></a>00641            l = l == n - 1 ? 0 : l + 1) {
<a name="l00642"></a>00642       <span class="comment">// Here r = state[(i - 1) mod n]</span>
<a name="l00643"></a>00643       <span class="comment">//      k = (i + (n - lag)/2) mod n</span>
<a name="l00644"></a>00644       <span class="comment">//      l = (i + (n - lag)/2 + lag) mod n</span>
<a name="l00645"></a>00645       r += state[i] + state[k];
<a name="l00646"></a>00646       r &amp;= mask;
<a name="l00647"></a>00647       r = c * (r ^ r &gt;&gt; (w - 5));
<a name="l00648"></a>00648       r &amp;= mask;
<a name="l00649"></a>00649       state[k] ^= r;
<a name="l00650"></a>00650       r -= i;
<a name="l00651"></a>00651       r &amp;= mask;
<a name="l00652"></a>00652       state[l] ^= r;
<a name="l00653"></a>00653       state[i] = r;
<a name="l00654"></a>00654     }
<a name="l00655"></a>00655   }
<a name="l00656"></a>00656 
<a name="l00657"></a>00657   <span class="comment">// RandomAlgorithm implementation</span>
<a name="l00658"></a>00658 
<a name="l00659"></a>00659   <span class="comment">// Here, input is I, J = I + 1, K = I + M; output is I = I + N (mod N)</span>
<a name="l00660"></a>00660 
<a name="l00661"></a><a class="code" href="Random_8cpp.html#a3110b17180afcc5842db5f2403f982e5">00661</a> <span class="preprocessor">#define MT19937_STEP(I, J, K) statev[I] = statev[K] ^       \</span>
<a name="l00662"></a>00662 <span class="preprocessor">    (statev[J] &amp; engine_type(1) ? magic : engine_type(0)) ^ \</span>
<a name="l00663"></a>00663 <span class="preprocessor">    ((statev[I] &amp; upper) | (statev[J] &amp; lower)) &gt;&gt; 1</span>
<a name="l00664"></a>00664 <span class="preprocessor"></span>
<a name="l00665"></a>00665   <span class="comment">// The code is cleaned up a little from Hagita&#39;s Fortran version by getting</span>
<a name="l00666"></a>00666   <span class="comment">// rid of the unnecessary masking by YMASK and by using simpler logic to</span>
<a name="l00667"></a>00667   <span class="comment">// restore the correct value of _state[0].</span>
<a name="l00668"></a>00668   <span class="comment">//</span>
<a name="l00669"></a>00669   <span class="comment">// Here input is J = I + N - 1, K = I + M - 1, and p = y[I] (only the high</span>
<a name="l00670"></a>00670   <span class="comment">// bits are used); output _state[I] and p = y[I - 1].</span>
<a name="l00671"></a>00671 
<a name="l00672"></a><a class="code" href="Random_8cpp.html#aab7773b3242f7ecf23db71ca5712ce92">00672</a> <span class="preprocessor">#define MT19937_REVSTEP(I, J, K) {                                  \</span>
<a name="l00673"></a>00673 <span class="preprocessor">    engine_type q = statev[J] ^ statev[K], s = q &gt;&gt; (width - 1);    \</span>
<a name="l00674"></a>00674 <span class="preprocessor">    q = (q ^ (s ? magic : engine_type(0))) &lt;&lt; 1 | s;                \</span>
<a name="l00675"></a>00675 <span class="preprocessor">    statev[I] = (p &amp; upper) | (q &amp; lower);                          \</span>
<a name="l00676"></a>00676 <span class="preprocessor">    p = q;                                                          \</span>
<a name="l00677"></a>00677 <span class="preprocessor">  }</span>
<a name="l00678"></a>00678 <span class="preprocessor"></span>
<a name="l00679"></a>00679   <span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomType&gt;
<a name="l00680"></a><a class="code" href="classRandomLib_1_1MT19937.html#ad4fd89787fa8b39c1a7817031f9c6fec">00680</a>   <span class="keywordtype">void</span> <a class="code" href="classRandomLib_1_1MT19937.html" title="The MT19937 random number engine.">MT19937&lt;RandomType&gt;::Transition</a>(<span class="keywordtype">long</span> <span class="keywordtype">long</span> count, <a class="code" href="classRandomLib_1_1MT19937.html#a97e60d2ba088951217f1e67d98fc4b71">internal_type</a> statev[])
<a name="l00681"></a>00681     <span class="keywordflow">throw</span>() {
<a name="l00682"></a>00682     <span class="keywordflow">if</span> (count &gt; 0)
<a name="l00683"></a>00683       <span class="keywordflow">for</span> (; count; --count) {
<a name="l00684"></a>00684         <span class="comment">// This ONLY uses high bit of statev[0]</span>
<a name="l00685"></a>00685         <span class="keywordtype">unsigned</span> i = 0;
<a name="l00686"></a>00686         <span class="keywordflow">for</span> (; i &lt; N - M; ++i) <a class="code" href="Random_8cpp.html#a3110b17180afcc5842db5f2403f982e5">MT19937_STEP</a>(i, i + 1, i + M    );
<a name="l00687"></a>00687         <span class="keywordflow">for</span> (; i &lt; N - 1; ++i) <a class="code" href="Random_8cpp.html#a3110b17180afcc5842db5f2403f982e5">MT19937_STEP</a>(i, i + 1, i + M - N);
<a name="l00688"></a>00688         <a class="code" href="Random_8cpp.html#a3110b17180afcc5842db5f2403f982e5">MT19937_STEP</a>(N - 1, 0, M - 1); <span class="comment">// i = N - 1</span>
<a name="l00689"></a>00689       }
<a name="l00690"></a>00690     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (count &lt; 0)
<a name="l00691"></a>00691       <span class="keywordflow">for</span> (; count; ++count) {
<a name="l00692"></a>00692         <span class="comment">// This ONLY uses high bit of statev[0]</span>
<a name="l00693"></a>00693         engine_type p = statev[0];
<a name="l00694"></a>00694         <span class="comment">// Fix low bits of statev[0] and compute y[-1]</span>
<a name="l00695"></a>00695         <a class="code" href="Random_8cpp.html#aab7773b3242f7ecf23db71ca5712ce92">MT19937_REVSTEP</a>(0, N - 1, M - 1); <span class="comment">// i = N</span>
<a name="l00696"></a>00696         <span class="keywordtype">unsigned</span> i = N - 1;
<a name="l00697"></a>00697         <span class="keywordflow">for</span> (; i &gt; N - M; --i) <a class="code" href="Random_8cpp.html#aab7773b3242f7ecf23db71ca5712ce92">MT19937_REVSTEP</a>(i, i - 1, i + M - 1 - N);
<a name="l00698"></a>00698         <span class="keywordflow">for</span> (; i        ; --i) <a class="code" href="Random_8cpp.html#aab7773b3242f7ecf23db71ca5712ce92">MT19937_REVSTEP</a>(i, i - 1, i + M - 1    );
<a name="l00699"></a>00699         <a class="code" href="Random_8cpp.html#aab7773b3242f7ecf23db71ca5712ce92">MT19937_REVSTEP</a>(0, N - 1, M - 1); <span class="comment">// i = 0</span>
<a name="l00700"></a>00700       }
<a name="l00701"></a>00701   }
<a name="l00702"></a>00702 
<a name="l00703"></a>00703 <span class="preprocessor">#undef MT19937_STEP</span>
<a name="l00704"></a>00704 <span class="preprocessor"></span><span class="preprocessor">#undef MT19937_REVSTEP</span>
<a name="l00705"></a>00705 <span class="preprocessor"></span>
<a name="l00706"></a>00706   <span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomType&gt;
<a name="l00707"></a><a class="code" href="classRandomLib_1_1MT19937.html#a3f6fc38e2f12fd08a60d6d3def4667f1">00707</a>   <span class="keywordtype">void</span> <a class="code" href="classRandomLib_1_1MT19937.html" title="The MT19937 random number engine.">MT19937&lt;RandomType&gt;::NormalizeState</a>(engine_type state[]) <span class="keywordflow">throw</span>() {
<a name="l00708"></a>00708 
<a name="l00709"></a>00709     <span class="comment">// Perform the MT-specific sanity check on the resulting state ensuring</span>
<a name="l00710"></a>00710     <span class="comment">// that the significant 19937 bits are not all zero.</span>
<a name="l00711"></a>00711     state[0] &amp;= upper;          <span class="comment">// Mask out unused bits</span>
<a name="l00712"></a>00712     <span class="keywordtype">unsigned</span> i = 0;
<a name="l00713"></a>00713     <span class="keywordflow">while</span> (i &lt; N &amp;&amp; state[i] == 0)
<a name="l00714"></a>00714       ++i;
<a name="l00715"></a>00715     <span class="keywordflow">if</span> (i &gt;= N)
<a name="l00716"></a>00716       state[0] = engine_type(1) &lt;&lt; (width - 1); <span class="comment">// with prob 2^-19937</span>
<a name="l00717"></a>00717 
<a name="l00718"></a>00718     <span class="comment">// This sets the low R bits of _state[0] consistent with the rest of the</span>
<a name="l00719"></a>00719     <span class="comment">// state.  Needed to handle SetCount(-N); Ran32(); immediately following</span>
<a name="l00720"></a>00720     <span class="comment">// reseeding.  This wasn&#39;t required in the original code because a</span>
<a name="l00721"></a>00721     <span class="comment">// Transition was always done first.</span>
<a name="l00722"></a>00722     engine_type q = state[N - 1] ^ state[M - 1], s = q &gt;&gt; (width - 1);
<a name="l00723"></a>00723     q = (q ^ (s ? magic : engine_type(0))) &lt;&lt; 1 | s;
<a name="l00724"></a>00724     state[0] = (state[0] &amp; upper) | (q &amp; lower);
<a name="l00725"></a>00725   }
<a name="l00726"></a>00726 
<a name="l00727"></a>00727   <span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomType&gt;
<a name="l00728"></a><a class="code" href="classRandomLib_1_1MT19937.html#aaa35a2924cf28b4028de988dba0923a2">00728</a>   <span class="keywordtype">void</span> <a class="code" href="classRandomLib_1_1MT19937.html" title="The MT19937 random number engine.">MT19937&lt;RandomType&gt;::CheckState</a>(<span class="keyword">const</span> engine_type state[],
<a name="l00729"></a>00729                                        <a class="code" href="classRandomLib_1_1RandomType.html#a99d4e836129ffa9171bc94375ff98546">Random_u32::type</a>&amp; check) {
<a name="l00730"></a>00730     engine_type x = 0;
<a name="l00731"></a>00731     <a class="code" href="classRandomLib_1_1RandomType.html#a99d4e836129ffa9171bc94375ff98546">Random_u32::type</a> c = check;
<a name="l00732"></a>00732     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; N; ++i) {
<a name="l00733"></a>00733       engine_t::CheckSum(state[i], c);
<a name="l00734"></a>00734       x |= state[i];
<a name="l00735"></a>00735     }
<a name="l00736"></a>00736     <span class="keywordflow">if</span> (x == 0)
<a name="l00737"></a>00737       <span class="keywordflow">throw</span> <a class="code" href="classRandomLib_1_1RandomErr.html" title="Exception handling for RandomLib.">RandomErr</a>(<span class="stringliteral">&quot;MT19937: All-zero state&quot;</span>);
<a name="l00738"></a>00738 
<a name="l00739"></a>00739     <span class="comment">// There are only width*(N-1) + 1 = 19937 independent bits of state.  Thus</span>
<a name="l00740"></a>00740     <span class="comment">// the low width-1 bits of _state[0] are derivable from the other bits in</span>
<a name="l00741"></a>00741     <span class="comment">// state.  Verify that the redundant bits bits are consistent.</span>
<a name="l00742"></a>00742     engine_type q = state[N - 1] ^ state[M - 1], s = q &gt;&gt; (width - 1);
<a name="l00743"></a>00743     q = (q ^ (s ? magic : engine_type(0))) &lt;&lt; 1 | s;
<a name="l00744"></a>00744     <span class="keywordflow">if</span> ((q ^ state[0]) &amp; lower)
<a name="l00745"></a>00745       <span class="keywordflow">throw</span> <a class="code" href="classRandomLib_1_1RandomErr.html" title="Exception handling for RandomLib.">RandomErr</a>(<span class="stringliteral">&quot;MT19937: Invalid state&quot;</span>);
<a name="l00746"></a>00746 
<a name="l00747"></a>00747     check = c;
<a name="l00748"></a>00748   }
<a name="l00749"></a>00749 
<a name="l00750"></a>00750 <span class="preprocessor">#if defined(HAVE_SSE2) &amp;&amp; HAVE_SSE2</span>
<a name="l00751"></a>00751 <span class="preprocessor"></span>
<a name="l00752"></a>00752   <span class="comment">// Transition is from Saito&#39;s Master&#39;s Thesis</span>
<a name="l00753"></a>00753   <span class="comment">// http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/M062821.pdf</span>
<a name="l00754"></a>00754   <span class="comment">//</span>
<a name="l00755"></a>00755   <span class="comment">// This implements</span>
<a name="l00756"></a>00756   <span class="comment">//</span>
<a name="l00757"></a>00757   <span class="comment">//     w_{i+N} = w_i A xor w_M B xor w_{i+N-2} C xor w_{i+N-1} D</span>
<a name="l00758"></a>00758   <span class="comment">//</span>
<a name="l00759"></a>00759   <span class="comment">// where w_i is a 128-bit word and</span>
<a name="l00760"></a>00760   <span class="comment">//</span>
<a name="l00761"></a>00761   <span class="comment">//     w A = (w &lt;&lt; 8)_128 xor w</span>
<a name="l00762"></a>00762   <span class="comment">//     w B = (w &gt;&gt; 11)_32 &amp; MSK</span>
<a name="l00763"></a>00763   <span class="comment">//     w C = (w &gt;&gt; 8)_128</span>
<a name="l00764"></a>00764   <span class="comment">//     w D = (w &lt;&lt; 18)_32</span>
<a name="l00765"></a>00765   <span class="comment">//</span>
<a name="l00766"></a>00766   <span class="comment">// Here the _128 means shift is of whole 128-bit word.  _32 means the shifts</span>
<a name="l00767"></a>00767   <span class="comment">// are independently done on each 32-bit word.</span>
<a name="l00768"></a>00768   <span class="comment">//</span>
<a name="l00769"></a>00769   <span class="comment">// In SFMT19937_STEP32 and SFMT19937_STEP64 input is I, J = I + M and output</span>
<a name="l00770"></a>00770   <span class="comment">// is I = I + N (mod N).  On input, s and r give state for I + N - 2 and I +</span>
<a name="l00771"></a>00771   <span class="comment">// N - 1; on output s and r give state for I + N - 1 and I + N.  The</span>
<a name="l00772"></a>00772   <span class="comment">// implementation of 128-bit operations is open-coded in a portable fashion</span>
<a name="l00773"></a>00773   <span class="comment">// (with LSB ordering).</span>
<a name="l00774"></a>00774   <span class="comment">//</span>
<a name="l00775"></a>00775   <span class="comment">// N.B. Here N and M are the lags in units of BitWidth words and so are 4</span>
<a name="l00776"></a>00776   <span class="comment">// (for u32 implementation) or 2 (for u64 implementation) times bigger than</span>
<a name="l00777"></a>00777   <span class="comment">// defined in Saito&#39;s thesis.</span>
<a name="l00778"></a>00778 
<a name="l00779"></a>00779   <span class="comment">// This is adapted from SFMT-sse.c in the SFMT 1.2 distribution.</span>
<a name="l00780"></a>00780   <span class="comment">// The order of instructions has been rearranged to increase the</span>
<a name="l00781"></a>00781   <span class="comment">// speed slightly</span>
<a name="l00782"></a>00782 
<a name="l00783"></a>00783 <span class="preprocessor">#define SFMT19937_STEP128(I, J) {                   \</span>
<a name="l00784"></a>00784 <span class="preprocessor">    internal_type x = _mm_load_si128(statev + I),   \</span>
<a name="l00785"></a>00785 <span class="preprocessor">      y = _mm_srli_epi32(statev[J], 11),            \</span>
<a name="l00786"></a>00786 <span class="preprocessor">      z = _mm_srli_si128(s, 1);                     \</span>
<a name="l00787"></a>00787 <span class="preprocessor">    s = _mm_slli_epi32(r, 18);                      \</span>
<a name="l00788"></a>00788 <span class="preprocessor">    z = _mm_xor_si128(z, x);                        \</span>
<a name="l00789"></a>00789 <span class="preprocessor">    x = _mm_slli_si128(x, 1);                       \</span>
<a name="l00790"></a>00790 <span class="preprocessor">    z = _mm_xor_si128(z, s);                        \</span>
<a name="l00791"></a>00791 <span class="preprocessor">    y = _mm_and_si128(y, m);                        \</span>
<a name="l00792"></a>00792 <span class="preprocessor">    z = _mm_xor_si128(z, x);                        \</span>
<a name="l00793"></a>00793 <span class="preprocessor">    s = r;                                          \</span>
<a name="l00794"></a>00794 <span class="preprocessor">    r = _mm_xor_si128(z, y);                        \</span>
<a name="l00795"></a>00795 <span class="preprocessor">    _mm_store_si128(statev + I, r);                 \</span>
<a name="l00796"></a>00796 <span class="preprocessor">  }</span>
<a name="l00797"></a>00797 <span class="preprocessor"></span>
<a name="l00798"></a>00798   <span class="comment">// This undoes SFMT19937_STEP.  Trivially, we have</span>
<a name="l00799"></a>00799   <span class="comment">//</span>
<a name="l00800"></a>00800   <span class="comment">//     w_i A = w_{i+N} xor w_{i+M} B xor w_{i+N-2} C xor w_{i+N-1} D</span>
<a name="l00801"></a>00801   <span class="comment">//</span>
<a name="l00802"></a>00802   <span class="comment">// Given w_i A we can determine w_i from the observation that A^16 =</span>
<a name="l00803"></a>00803   <span class="comment">// identity, thus</span>
<a name="l00804"></a>00804   <span class="comment">//</span>
<a name="l00805"></a>00805   <span class="comment">//     w_i = (w_i A) A^15</span>
<a name="l00806"></a>00806   <span class="comment">//</span>
<a name="l00807"></a>00807   <span class="comment">// Because x A^(2^n) = x &lt;&lt; (8*2^n) xor x, the operation y = x A^15 can be</span>
<a name="l00808"></a>00808   <span class="comment">// implemented as</span>
<a name="l00809"></a>00809   <span class="comment">//</span>
<a name="l00810"></a>00810   <span class="comment">//     y&#39;   = (x    &lt;&lt; 64)_128 xor x    = x    A^8</span>
<a name="l00811"></a>00811   <span class="comment">//     y&#39;&#39;  = (y&#39;   &lt;&lt; 32)_128 xor y&#39;   = y&#39;   A^4 = x A^12</span>
<a name="l00812"></a>00812   <span class="comment">//     y&#39;&#39;&#39; = (y&#39;&#39;  &lt;&lt; 16)_128 xor y&#39;&#39;  = y&#39;&#39;  A^2 = x A^14</span>
<a name="l00813"></a>00813   <span class="comment">//     y    = (y&#39;&#39;&#39; &lt;&lt;  8)_128 xor y&#39;&#39;&#39; = y&#39;&#39;&#39; A   = x A^15</span>
<a name="l00814"></a>00814   <span class="comment">//</span>
<a name="l00815"></a>00815   <span class="comment">// Here input is I = I + N, J = I + M, K = I + N - 2, L = I + N -1, and</span>
<a name="l00816"></a>00816   <span class="comment">// output is I = I.</span>
<a name="l00817"></a>00817   <span class="comment">//</span>
<a name="l00818"></a>00818   <span class="comment">// This is about 15-35% times slower than SFMT19937_STEPNN, because (1) there</span>
<a name="l00819"></a>00819   <span class="comment">// doesn&#39;t appear to be a straightforward way of saving intermediate results</span>
<a name="l00820"></a>00820   <span class="comment">// across calls as with SFMT19937_STEPNN and (2) w A^15 is slower to compute</span>
<a name="l00821"></a>00821   <span class="comment">// than w A.</span>
<a name="l00822"></a>00822 
<a name="l00823"></a>00823 <span class="preprocessor">#define SFMT19937_REVSTEP128(I, J, K, L) {              \</span>
<a name="l00824"></a>00824 <span class="preprocessor">    internal_type x = _mm_load_si128(statev + I),       \</span>
<a name="l00825"></a>00825 <span class="preprocessor">      y = _mm_srli_epi32(statev[J], 11),                \</span>
<a name="l00826"></a>00826 <span class="preprocessor">      z = _mm_slli_epi32(statev[L], 18);                \</span>
<a name="l00827"></a>00827 <span class="preprocessor">    y = _mm_and_si128(y, m);                            \</span>
<a name="l00828"></a>00828 <span class="preprocessor">    x = _mm_xor_si128(x, _mm_srli_si128(statev[K], 1)); \</span>
<a name="l00829"></a>00829 <span class="preprocessor">    x = _mm_xor_si128(x, z);                            \</span>
<a name="l00830"></a>00830 <span class="preprocessor">    x = _mm_xor_si128(x, y);                            \</span>
<a name="l00831"></a>00831 <span class="preprocessor">    x = _mm_xor_si128(_mm_slli_si128(x, 8), x);         \</span>
<a name="l00832"></a>00832 <span class="preprocessor">    x = _mm_xor_si128(_mm_slli_si128(x, 4), x);         \</span>
<a name="l00833"></a>00833 <span class="preprocessor">    x = _mm_xor_si128(_mm_slli_si128(x, 2), x);         \</span>
<a name="l00834"></a>00834 <span class="preprocessor">    x = _mm_xor_si128(_mm_slli_si128(x, 1), x);         \</span>
<a name="l00835"></a>00835 <span class="preprocessor">    _mm_store_si128(statev + I, x);                     \</span>
<a name="l00836"></a>00836 <span class="preprocessor">  }</span>
<a name="l00837"></a>00837 <span class="preprocessor"></span>
<a name="l00838"></a>00838   <span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomType&gt;
<a name="l00839"></a>00839   <span class="keywordtype">void</span> <a class="code" href="classRandomLib_1_1SFMT19937.html" title="The SFMT random number engine.">SFMT19937&lt;RandomType&gt;::Transition</a>(<span class="keywordtype">long</span> <span class="keywordtype">long</span> count,
<a name="l00840"></a>00840                                          internal_type statev[])
<a name="l00841"></a>00841     <span class="keywordflow">throw</span>() {
<a name="l00842"></a>00842     <span class="keyword">const</span> internal_type m = _mm_set_epi32(magic3, magic2, magic1, magic0);
<a name="l00843"></a>00843     <span class="keywordflow">if</span> (count &gt; 0) {
<a name="l00844"></a>00844       internal_type s = _mm_load_si128(statev + N128 - 2),
<a name="l00845"></a>00845         r = _mm_load_si128(statev + N128 - 1);
<a name="l00846"></a>00846       <span class="keywordflow">for</span> (; count; --count) {
<a name="l00847"></a>00847         <span class="keywordtype">unsigned</span> i = 0;
<a name="l00848"></a>00848         <span class="keywordflow">for</span> (; i + M128 &lt; N128; ++i) SFMT19937_STEP128(i, i + M128       );
<a name="l00849"></a>00849         <span class="keywordflow">for</span> (; i &lt; N128       ; ++i) SFMT19937_STEP128(i, i + M128 - N128);
<a name="l00850"></a>00850       }
<a name="l00851"></a>00851     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (count &lt; 0)
<a name="l00852"></a>00852       <span class="keywordflow">for</span> (; count; ++count) {
<a name="l00853"></a>00853         <span class="keywordtype">unsigned</span> i = N128;
<a name="l00854"></a>00854         <span class="keywordflow">for</span> (; i + M128 &gt; N128;) {
<a name="l00855"></a>00855           --i; SFMT19937_REVSTEP128(i, i + M128 - N128, i - 2, i - 1);
<a name="l00856"></a>00856         }
<a name="l00857"></a>00857         <span class="keywordflow">for</span> (; i &gt; 2;) {
<a name="l00858"></a>00858           --i; SFMT19937_REVSTEP128(i, i + M128, i - 2, i - 1);
<a name="l00859"></a>00859         }
<a name="l00860"></a>00860         SFMT19937_REVSTEP128(1, M128 + 1, N128 - 1, 0       ); <span class="comment">// i = 1</span>
<a name="l00861"></a>00861         SFMT19937_REVSTEP128(0, M128    , N128 - 2, N128 - 1); <span class="comment">// i = 0</span>
<a name="l00862"></a>00862       }
<a name="l00863"></a>00863   }
<a name="l00864"></a>00864 
<a name="l00865"></a>00865 <span class="preprocessor">#undef SFMT19937_STEP128</span>
<a name="l00866"></a>00866 <span class="preprocessor"></span><span class="preprocessor">#undef SFMT19937_REVSTEP128</span>
<a name="l00867"></a>00867 <span class="preprocessor"></span>
<a name="l00868"></a>00868 <span class="preprocessor">#elif defined(HAVE_ALTIVEC) &amp;&amp; HAVE_ALTIVEC</span>
<a name="l00869"></a>00869 <span class="preprocessor"></span>
<a name="l00870"></a>00870   <span class="comment">// The Altivec versions of SFMT19937_{,REV}STEP128 are simply translated from</span>
<a name="l00871"></a>00871   <span class="comment">// the SSE2 versions.  The only significant differences arise because of the</span>
<a name="l00872"></a>00872   <span class="comment">// MSB ordering of the PowerPC.  This means that the 32-bit and 64-bit</span>
<a name="l00873"></a>00873   <span class="comment">// versions are no different because 32-bit and 64-bit words don&#39;t pack</span>
<a name="l00874"></a>00874   <span class="comment">// together in the same way as on an SSE2 machine (see the two definitions of</span>
<a name="l00875"></a>00875   <span class="comment">// magic).  This also means that the 128-bit byte shifts on an LSB machine</span>
<a name="l00876"></a>00876   <span class="comment">// change into more complicated byte permutations.</span>
<a name="l00877"></a>00877 
<a name="l00878"></a>00878 <span class="preprocessor">#define ALTIVEC_PERM(X, P) vec_perm(X, P, P)</span>
<a name="l00879"></a>00879 <span class="preprocessor"></span>
<a name="l00880"></a>00880 <span class="preprocessor">#define SFMT19937_STEP128(I, J) {                               \</span>
<a name="l00881"></a>00881 <span class="preprocessor">    internal_type x = statev[I],                                \</span>
<a name="l00882"></a>00882 <span class="preprocessor">      z = vec_xor(vec_xor(ALTIVEC_PERM(s, right1), x),          \</span>
<a name="l00883"></a>00883 <span class="preprocessor">                  vec_sl(r, bitleft));                          \</span>
<a name="l00884"></a>00884 <span class="preprocessor">    s = r;                                                      \</span>
<a name="l00885"></a>00885 <span class="preprocessor">    r = vec_xor(z,                                              \</span>
<a name="l00886"></a>00886 <span class="preprocessor">                vec_xor(ALTIVEC_PERM(x, left1),                 \</span>
<a name="l00887"></a>00887 <span class="preprocessor">                        vec_and(vec_sr(statev[J], bitright),    \</span>
<a name="l00888"></a>00888 <span class="preprocessor">                                magic)));                       \</span>
<a name="l00889"></a>00889 <span class="preprocessor">    statev[I] = r;                                              \</span>
<a name="l00890"></a>00890 <span class="preprocessor">  }</span>
<a name="l00891"></a>00891 <span class="preprocessor"></span>
<a name="l00892"></a>00892 <span class="preprocessor">#define SFMT19937_REVSTEP128(I, J, K, L) {              \</span>
<a name="l00893"></a>00893 <span class="preprocessor">    internal_type x = statev[I],                        \</span>
<a name="l00894"></a>00894 <span class="preprocessor">      y = vec_sr(statev[J], bitright),                  \</span>
<a name="l00895"></a>00895 <span class="preprocessor">      z = vec_sl(statev[L], bitleft);                   \</span>
<a name="l00896"></a>00896 <span class="preprocessor">    y = vec_and(y, magic);                              \</span>
<a name="l00897"></a>00897 <span class="preprocessor">    x = vec_xor(x, ALTIVEC_PERM(statev[K], right1));    \</span>
<a name="l00898"></a>00898 <span class="preprocessor">    x = vec_xor(x, z);                                  \</span>
<a name="l00899"></a>00899 <span class="preprocessor">    x = vec_xor(x, y);                                  \</span>
<a name="l00900"></a>00900 <span class="preprocessor">    x = vec_xor(ALTIVEC_PERM(x, left8), x);             \</span>
<a name="l00901"></a>00901 <span class="preprocessor">    x = vec_xor(ALTIVEC_PERM(x, left4), x);             \</span>
<a name="l00902"></a>00902 <span class="preprocessor">    x = vec_xor(ALTIVEC_PERM(x, left2), x);             \</span>
<a name="l00903"></a>00903 <span class="preprocessor">    statev[I] = vec_xor(ALTIVEC_PERM(x, left1), x);     \</span>
<a name="l00904"></a>00904 <span class="preprocessor">  }</span>
<a name="l00905"></a>00905 <span class="preprocessor"></span>
<a name="l00906"></a>00906   <span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomType&gt;
<a name="l00907"></a>00907   <span class="keywordtype">void</span> SFMT19937&lt;RandomType&gt;::Transition(<span class="keywordtype">long</span> <span class="keywordtype">long</span> count,
<a name="l00908"></a>00908                                          internal_type statev[])
<a name="l00909"></a>00909     <span class="keywordflow">throw</span>() {
<a name="l00910"></a>00910     <span class="keyword">const</span> internal_type magic = width == 32 ?
<a name="l00911"></a>00911       (vector unsigned)(magic0, magic1, magic2, magic3) :
<a name="l00912"></a>00912       (vector unsigned)(magic1, magic0, magic3, magic2),
<a name="l00913"></a>00913       bitleft = (vector unsigned)(18, 18, 18, 18),
<a name="l00914"></a>00914       bitright = (vector unsigned)(11, 11, 11, 11);
<a name="l00915"></a>00915     <span class="comment">// Shift left and right by 1 byte.  Note that vec_perm(X, Y, P) glues X and</span>
<a name="l00916"></a>00916     <span class="comment">// Y together into a 32-byte quantity and then the 16-byte permutation</span>
<a name="l00917"></a>00917     <span class="comment">// vector P specifies which bytes to put into the 16-byte output.  We</span>
<a name="l00918"></a>00918     <span class="comment">// follow here the convention of using Y = P and using the zero entries in</span>
<a name="l00919"></a>00919     <span class="comment">// P to allow zero bytes to be introduces into the shifted output.  The</span>
<a name="l00920"></a>00920     <span class="comment">// following describes how the left1 table (32-bit version) is produced:</span>
<a name="l00921"></a>00921     <span class="comment">//</span>
<a name="l00922"></a>00922     <span class="comment">// Byte layout of original with LSB ordering</span>
<a name="l00923"></a>00923     <span class="comment">// 33 32 31 30  23 22 21 20  13 12 11 10  03 02 01 00</span>
<a name="l00924"></a>00924     <span class="comment">// shift left by 1 byte (z means zeros enter)</span>
<a name="l00925"></a>00925     <span class="comment">// 32 31 30 23  22 21 20 13  12 11 10 03  02 01 00 zz</span>
<a name="l00926"></a>00926     <span class="comment">//</span>
<a name="l00927"></a>00927     <span class="comment">// Rearrange original to LSB order in 4-byte units</span>
<a name="l00928"></a>00928     <span class="comment">// 03 02 01 00  13 12 11 10  23 22 21 20  33 32 31 30</span>
<a name="l00929"></a>00929     <span class="comment">// with sequential MSB byte indices</span>
<a name="l00930"></a>00930     <span class="comment">// 0  1  2  3   4  5  6  7   8  9 10 11  12 13 14 15</span>
<a name="l00931"></a>00931     <span class="comment">//</span>
<a name="l00932"></a>00932     <span class="comment">// Rearrange shift left verion to LSB order in 4-byte units</span>
<a name="l00933"></a>00933     <span class="comment">// 02 01 00 zz  12 11 10 03  22 21 20 13  32 31 30 23</span>
<a name="l00934"></a>00934     <span class="comment">// with corresponding MSB byte indices</span>
<a name="l00935"></a>00935     <span class="comment">// 1  2  3  z   5  6  7  0   9 10 11  4  13 14 15  8</span>
<a name="l00936"></a>00936     <span class="comment">//</span>
<a name="l00937"></a>00937     <span class="comment">// Replace byte index at x by 16 + index of 0 = 16 + 7 = 23 to give</span>
<a name="l00938"></a>00938     <span class="comment">// 1  2  3 23   5  6  7  0   9 10 11  4  13 14 15  8</span>
<a name="l00939"></a>00939     <span class="keyword">const</span> vector <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> left1 = width == 32 ?
<a name="l00940"></a>00940       (vector <span class="keywordtype">unsigned</span> char)(1,2,3,23, 5,6,7,0, 9,10,11,4, 13,14,15,8) :
<a name="l00941"></a>00941       (vector <span class="keywordtype">unsigned</span> char)(1,2,3,4,5,6,7,31, 9,10,11,12,13,14,15,0),
<a name="l00942"></a>00942       right1 = width == 32 ?
<a name="l00943"></a>00943       (vector <span class="keywordtype">unsigned</span> char)(7,0,1,2, 11,4,5,6, 15,8,9,10, 17,12,13,14) :
<a name="l00944"></a>00944       (vector <span class="keywordtype">unsigned</span> char)(15,0,1,2,3,4,5,6, 17,8,9,10,11,12,13,14);
<a name="l00945"></a>00945     <span class="keywordflow">if</span> (count &gt; 0) {
<a name="l00946"></a>00946       internal_type s = statev[N128 - 2],
<a name="l00947"></a>00947         r = statev[N128 - 1];
<a name="l00948"></a>00948       <span class="keywordflow">for</span> (; count; --count) {
<a name="l00949"></a>00949         <span class="keywordtype">unsigned</span> i = 0;
<a name="l00950"></a>00950         <span class="keywordflow">for</span> (; i + M128 &lt; N128; ++i) SFMT19937_STEP128(i, i + M128       );
<a name="l00951"></a>00951         <span class="keywordflow">for</span> (; i &lt; N128       ; ++i) SFMT19937_STEP128(i, i + M128 - N128);
<a name="l00952"></a>00952       }
<a name="l00953"></a>00953     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (count &lt; 0) {
<a name="l00954"></a>00954       <span class="comment">// leftN shifts left by N bytes.</span>
<a name="l00955"></a>00955       <span class="keyword">const</span> vector <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> left2 = width == 32 ?
<a name="l00956"></a>00956         (vector <span class="keywordtype">unsigned</span> char)(2,3,22,22, 6,7,0,1, 10,11,4,5, 14,15,8,9) :
<a name="l00957"></a>00957         (vector <span class="keywordtype">unsigned</span> char)(2,3,4,5,6,7,30,30, 10,11,12,13,14,15,0,1),
<a name="l00958"></a>00958         left4 = width == 32 ?
<a name="l00959"></a>00959         (vector <span class="keywordtype">unsigned</span> char)(20,20,20,20, 0,1,2,3, 4,5,6,7, 8,9,10,11) :
<a name="l00960"></a>00960         (vector <span class="keywordtype">unsigned</span> char)(4,5,6,7,28,28,28,28, 12,13,14,15,0,1,2,3),
<a name="l00961"></a>00961         left8 = (vector <span class="keywordtype">unsigned</span> char)(24,24,24,24,24,24,24,24,0,1,2,3,4,5,6,7);
<a name="l00962"></a>00962       <span class="keywordflow">for</span> (; count; ++count) {
<a name="l00963"></a>00963         <span class="keywordtype">unsigned</span> i = N128;
<a name="l00964"></a>00964         <span class="keywordflow">for</span> (; i + M128 &gt; N128;) {
<a name="l00965"></a>00965           --i; SFMT19937_REVSTEP128(i, i + M128 - N128, i - 2, i - 1);
<a name="l00966"></a>00966         }
<a name="l00967"></a>00967         <span class="keywordflow">for</span> (; i &gt; 2;) {
<a name="l00968"></a>00968           --i; SFMT19937_REVSTEP128(i, i + M128, i - 2, i - 1);
<a name="l00969"></a>00969         }
<a name="l00970"></a>00970         SFMT19937_REVSTEP128(1, M128 + 1, N128 - 1, 0       ); <span class="comment">// i = 1</span>
<a name="l00971"></a>00971         SFMT19937_REVSTEP128(0, M128    , N128 - 2, N128 - 1); <span class="comment">// i = 0</span>
<a name="l00972"></a>00972       }
<a name="l00973"></a>00973     }
<a name="l00974"></a>00974   }
<a name="l00975"></a>00975 
<a name="l00976"></a>00976 <span class="preprocessor">#undef SFMT19937_STEP128</span>
<a name="l00977"></a>00977 <span class="preprocessor"></span><span class="preprocessor">#undef SFMT19937_REVSTEP128</span>
<a name="l00978"></a>00978 <span class="preprocessor"></span><span class="preprocessor">#undef ALTIVEC_PERM</span>
<a name="l00979"></a>00979 <span class="preprocessor"></span>
<a name="l00980"></a>00980 <span class="preprocessor">#else  // neither HAVE_SSE2 or HAVE_ALTIVEC</span>
<a name="l00981"></a>00981 <span class="preprocessor"></span>
<a name="l00982"></a><a class="code" href="Random_8cpp.html#ad8eb09cc7719a283bf83368334b3bc13">00982</a> <span class="preprocessor">#define SFMT19937_STEP32(I, J) {                            \</span>
<a name="l00983"></a>00983 <span class="preprocessor">    internal_type t = statev[I] ^ statev[I] &lt;&lt; 8 ^          \</span>
<a name="l00984"></a>00984 <span class="preprocessor">      (statev[J] &gt;&gt; 11 &amp; magic0) ^                          \</span>
<a name="l00985"></a>00985 <span class="preprocessor">      (s0 &gt;&gt; 8 | s1 &lt;&lt; 24) ^ r0 &lt;&lt; 18;                      \</span>
<a name="l00986"></a>00986 <span class="preprocessor">    s0 = r0; r0 = t &amp; mask;                                 \</span>
<a name="l00987"></a>00987 <span class="preprocessor">    t = statev[I + 1] ^                                     \</span>
<a name="l00988"></a>00988 <span class="preprocessor">      (statev[I + 1] &lt;&lt; 8 | statev[I] &gt;&gt; 24) ^              \</span>
<a name="l00989"></a>00989 <span class="preprocessor">      (statev[J + 1] &gt;&gt; 11 &amp; magic1) ^                      \</span>
<a name="l00990"></a>00990 <span class="preprocessor">      (s1 &gt;&gt; 8 | s2 &lt;&lt; 24) ^ r1 &lt;&lt; 18;                      \</span>
<a name="l00991"></a>00991 <span class="preprocessor">    s1 = r1; r1 = t &amp; mask;                                 \</span>
<a name="l00992"></a>00992 <span class="preprocessor">    t = statev[I + 2] ^                                     \</span>
<a name="l00993"></a>00993 <span class="preprocessor">      (statev[I + 2] &lt;&lt; 8 | statev[I + 1] &gt;&gt; 24) ^          \</span>
<a name="l00994"></a>00994 <span class="preprocessor">      (statev[J + 2] &gt;&gt; 11 &amp; magic2) ^                      \</span>
<a name="l00995"></a>00995 <span class="preprocessor">      (s2 &gt;&gt; 8 | s3 &lt;&lt; 24) ^ r2 &lt;&lt; 18;                      \</span>
<a name="l00996"></a>00996 <span class="preprocessor">    s2 = r2; r2 = t &amp; mask;                                 \</span>
<a name="l00997"></a>00997 <span class="preprocessor">    t = statev[I + 3] ^                                     \</span>
<a name="l00998"></a>00998 <span class="preprocessor">      (statev[I + 3] &lt;&lt; 8 | statev[I + 2] &gt;&gt; 24) ^          \</span>
<a name="l00999"></a>00999 <span class="preprocessor">      (statev[J + 3] &gt;&gt; 11 &amp; magic3) ^ s3 &gt;&gt; 8 ^ r3 &lt;&lt; 18;  \</span>
<a name="l01000"></a>01000 <span class="preprocessor">    s3 = r3; r3 = t &amp; mask;                                 \</span>
<a name="l01001"></a>01001 <span class="preprocessor">    statev[I    ] = r0; statev[I + 1] = r1;                 \</span>
<a name="l01002"></a>01002 <span class="preprocessor">    statev[I + 2] = r2; statev[I + 3] = r3;                 \</span>
<a name="l01003"></a>01003 <span class="preprocessor">  }</span>
<a name="l01004"></a>01004 <span class="preprocessor"></span>
<a name="l01005"></a><a class="code" href="Random_8cpp.html#a24ff3c91fea149819dc2183107f5e378">01005</a> <span class="preprocessor">#define SFMT19937_REVSTEP32(I, J, K, L) {                   \</span>
<a name="l01006"></a>01006 <span class="preprocessor">    internal_type                                           \</span>
<a name="l01007"></a>01007 <span class="preprocessor">      t0 = (statev[I] ^ (statev[J] &gt;&gt; 11 &amp; magic0) ^        \</span>
<a name="l01008"></a>01008 <span class="preprocessor">            (statev[K] &gt;&gt; 8 | statev[K + 1] &lt;&lt; 24) ^        \</span>
<a name="l01009"></a>01009 <span class="preprocessor">            statev[L] &lt;&lt; 18) &amp; mask,                        \</span>
<a name="l01010"></a>01010 <span class="preprocessor">      t1 = (statev[I + 1] ^                                 \</span>
<a name="l01011"></a>01011 <span class="preprocessor">            (statev[J + 1] &gt;&gt; 11 &amp; magic1) ^                \</span>
<a name="l01012"></a>01012 <span class="preprocessor">            (statev[K + 1] &gt;&gt; 8 | statev[K + 2] &lt;&lt; 24) ^    \</span>
<a name="l01013"></a>01013 <span class="preprocessor">            statev[L + 1] &lt;&lt; 18) &amp; mask,                    \</span>
<a name="l01014"></a>01014 <span class="preprocessor">      t2 = (statev[I + 2] ^                                 \</span>
<a name="l01015"></a>01015 <span class="preprocessor">            (statev[J + 2] &gt;&gt; 11 &amp; magic2) ^                \</span>
<a name="l01016"></a>01016 <span class="preprocessor">            (statev[K + 2] &gt;&gt; 8 | statev[K + 3] &lt;&lt; 24) ^    \</span>
<a name="l01017"></a>01017 <span class="preprocessor">            statev[L + 2] &lt;&lt; 18) &amp; mask,                    \</span>
<a name="l01018"></a>01018 <span class="preprocessor">      t3 = (statev[I + 3] ^                                 \</span>
<a name="l01019"></a>01019 <span class="preprocessor">            (statev[J + 3] &gt;&gt; 11 &amp; magic3) ^                \</span>
<a name="l01020"></a>01020 <span class="preprocessor">            statev[K + 3] &gt;&gt; 8 ^                            \</span>
<a name="l01021"></a>01021 <span class="preprocessor">            statev[L + 3] &lt;&lt; 18) &amp; mask;                    \</span>
<a name="l01022"></a>01022 <span class="preprocessor">    t3 ^= t1; t2 ^= t0; t3 ^= t2; t2 ^= t1; t1 ^= t0;       \</span>
<a name="l01023"></a>01023 <span class="preprocessor">    t3 ^= t2 &gt;&gt; 16 | (t3 &lt;&lt; 16 &amp; mask);                     \</span>
<a name="l01024"></a>01024 <span class="preprocessor">    t2 ^= t1 &gt;&gt; 16 | (t2 &lt;&lt; 16 &amp; mask);                     \</span>
<a name="l01025"></a>01025 <span class="preprocessor">    t1 ^= t0 &gt;&gt; 16 | (t1 &lt;&lt; 16 &amp; mask);                     \</span>
<a name="l01026"></a>01026 <span class="preprocessor">    t0 ^=             t0 &lt;&lt; 16 &amp; mask;                      \</span>
<a name="l01027"></a>01027 <span class="preprocessor">    statev[I    ] = t0 ^             (t0 &lt;&lt; 8 &amp; mask);      \</span>
<a name="l01028"></a>01028 <span class="preprocessor">    statev[I + 1] = t1 ^ (t0 &gt;&gt; 24 | (t1 &lt;&lt; 8 &amp; mask));     \</span>
<a name="l01029"></a>01029 <span class="preprocessor">    statev[I + 2] = t2 ^ (t1 &gt;&gt; 24 | (t2 &lt;&lt; 8 &amp; mask));     \</span>
<a name="l01030"></a>01030 <span class="preprocessor">    statev[I + 3] = t3 ^ (t2 &gt;&gt; 24 | (t3 &lt;&lt; 8 &amp; mask));     \</span>
<a name="l01031"></a>01031 <span class="preprocessor">  }</span>
<a name="l01032"></a>01032 <span class="preprocessor"></span>
<a name="l01033"></a>01033   <span class="keyword">template</span>&lt;&gt;
<a name="l01034"></a><a class="code" href="classRandomLib_1_1SFMT19937.html#adeb349785db5eecb39a53d5621ce5944">01034</a>   <span class="keywordtype">void</span> <a class="code" href="classRandomLib_1_1SFMT19937.html" title="The SFMT random number engine.">SFMT19937&lt;Random_u32&gt;::Transition</a>(<span class="keywordtype">long</span> <span class="keywordtype">long</span> count,
<a name="l01035"></a>01035                                          <a class="code" href="classRandomLib_1_1SFMT19937.html#a0c73ae390b2bbe77f8610a8506b4a896">internal_type</a> statev[])
<a name="l01036"></a>01036     <span class="keywordflow">throw</span>() {
<a name="l01037"></a>01037     <span class="keywordflow">if</span> (count &gt; 0) {
<a name="l01038"></a>01038       <span class="comment">// x[i+N] = g(x[i], x[i+M], x[i+N-2], x[i,N-1])</span>
<a name="l01039"></a>01039       <a class="code" href="classRandomLib_1_1SFMT19937.html#a0c73ae390b2bbe77f8610a8506b4a896">internal_type</a>
<a name="l01040"></a>01040         s0 = statev[N - 8], s1 = statev[N - 7],
<a name="l01041"></a>01041         s2 = statev[N - 6], s3 = statev[N - 5],
<a name="l01042"></a>01042         r0 = statev[N - 4], r1 = statev[N - 3],
<a name="l01043"></a>01043         r2 = statev[N - 2], r3 = statev[N - 1];
<a name="l01044"></a>01044       <span class="keywordflow">for</span> (; count; --count) {
<a name="l01045"></a>01045         <span class="keywordtype">unsigned</span> i = 0;
<a name="l01046"></a>01046         <span class="keywordflow">for</span> (; i + M &lt; N; i += R) <a class="code" href="Random_8cpp.html#ad8eb09cc7719a283bf83368334b3bc13">SFMT19937_STEP32</a>(i, i + M    );
<a name="l01047"></a>01047         <span class="keywordflow">for</span> (; i &lt; N    ; i += R) <a class="code" href="Random_8cpp.html#ad8eb09cc7719a283bf83368334b3bc13">SFMT19937_STEP32</a>(i, i + M - N);
<a name="l01048"></a>01048       }
<a name="l01049"></a>01049     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (count &lt; 0)
<a name="l01050"></a>01050       <span class="keywordflow">for</span> (; count; ++count) {
<a name="l01051"></a>01051         <span class="keywordtype">unsigned</span> i = N;
<a name="l01052"></a>01052         <span class="keywordflow">for</span> (; i + M &gt; N;) {
<a name="l01053"></a>01053           i -= R; <a class="code" href="Random_8cpp.html#a24ff3c91fea149819dc2183107f5e378">SFMT19937_REVSTEP32</a>(i, i + M - N, i - 2 * R, i - R);
<a name="l01054"></a>01054         }
<a name="l01055"></a>01055         <span class="keywordflow">for</span> (; i &gt; 2 * R;) {
<a name="l01056"></a>01056           i -= R; <a class="code" href="Random_8cpp.html#a24ff3c91fea149819dc2183107f5e378">SFMT19937_REVSTEP32</a>(i, i + M    , i - 2 * R, i - R);
<a name="l01057"></a>01057         }
<a name="l01058"></a>01058         <a class="code" href="Random_8cpp.html#a24ff3c91fea149819dc2183107f5e378">SFMT19937_REVSTEP32</a>(R, M + R, N -     R, 0    ); <span class="comment">// i = R</span>
<a name="l01059"></a>01059         <a class="code" href="Random_8cpp.html#a24ff3c91fea149819dc2183107f5e378">SFMT19937_REVSTEP32</a>(0, M    , N - 2 * R, N - R); <span class="comment">// i = 0</span>
<a name="l01060"></a>01060       }
<a name="l01061"></a>01061   }
<a name="l01062"></a>01062 
<a name="l01063"></a>01063 <span class="preprocessor">#undef SFMT19937_STEP32</span>
<a name="l01064"></a>01064 <span class="preprocessor"></span><span class="preprocessor">#undef SFMT19937_REVSTEP32</span>
<a name="l01065"></a>01065 <span class="preprocessor"></span>
<a name="l01066"></a><a class="code" href="Random_8cpp.html#aa128846cf5f317e1fbbda2f64fa82d63">01066</a> <span class="preprocessor">#define SFMT19937_STEP64(I, J) {                    \</span>
<a name="l01067"></a>01067 <span class="preprocessor">    internal_type t = statev[I] ^ statev[I] &lt;&lt; 8 ^  \</span>
<a name="l01068"></a>01068 <span class="preprocessor">      (statev[J] &gt;&gt; 11 &amp; magic0) ^                  \</span>
<a name="l01069"></a>01069 <span class="preprocessor">      (s0 &gt;&gt; 8 | s1 &lt;&lt; 56) ^ (r0 &lt;&lt; 18 &amp; mask18);   \</span>
<a name="l01070"></a>01070 <span class="preprocessor">    s0 = r0; r0 = t &amp; mask;                         \</span>
<a name="l01071"></a>01071 <span class="preprocessor">    t = statev[I + 1] ^                             \</span>
<a name="l01072"></a>01072 <span class="preprocessor">      (statev[I + 1] &lt;&lt; 8 | statev[I] &gt;&gt; 56) ^      \</span>
<a name="l01073"></a>01073 <span class="preprocessor">      (statev[J + 1] &gt;&gt; 11 &amp; magic1) ^              \</span>
<a name="l01074"></a>01074 <span class="preprocessor">      s1 &gt;&gt; 8 ^ (r1 &lt;&lt; 18 &amp; mask18);                \</span>
<a name="l01075"></a>01075 <span class="preprocessor">    s1 = r1; r1 = t &amp; mask;                         \</span>
<a name="l01076"></a>01076 <span class="preprocessor">    statev[I] = r0; statev[I + 1] = r1;             \</span>
<a name="l01077"></a>01077 <span class="preprocessor">  }</span>
<a name="l01078"></a>01078 <span class="preprocessor"></span>
<a name="l01079"></a>01079   <span class="comment">// In combining the left and right shifts to simulate a 128-bit shift we</span>
<a name="l01080"></a>01080   <span class="comment">// usually use or.  However we can equivalently use xor (e.g., t1 &lt;&lt; 8 ^ t0</span>
<a name="l01081"></a>01081   <span class="comment">// &gt;&gt; 56 instead of t1 ^ t1 &lt;&lt; 8 | t0 &gt;&gt; 56) and this speeds up the code if</span>
<a name="l01082"></a>01082   <span class="comment">// used in some places.</span>
<a name="l01083"></a>01083 
<a name="l01084"></a><a class="code" href="Random_8cpp.html#a1ed27c4ec006a5cdb9728765f370d3e2">01084</a> <span class="preprocessor">#define SFMT19937_REVSTEP64(I, J, K, L) {                   \</span>
<a name="l01085"></a>01085 <span class="preprocessor">    internal_type                                           \</span>
<a name="l01086"></a>01086 <span class="preprocessor">      t0 = statev[I] ^ (statev[J] &gt;&gt; 11 &amp; magic0) ^         \</span>
<a name="l01087"></a>01087 <span class="preprocessor">      (statev[K] &gt;&gt; 8 | (statev[K + 1] &lt;&lt; 56 &amp; mask)) ^     \</span>
<a name="l01088"></a>01088 <span class="preprocessor">      (statev[L] &lt;&lt; 18 &amp; mask18),                           \</span>
<a name="l01089"></a>01089 <span class="preprocessor">      t1 = statev[I + 1] ^ (statev[J + 1] &gt;&gt; 11 &amp; magic1) ^ \</span>
<a name="l01090"></a>01090 <span class="preprocessor">      statev[K + 1] &gt;&gt; 8 ^ (statev[L + 1] &lt;&lt; 18 &amp; mask18);  \</span>
<a name="l01091"></a>01091 <span class="preprocessor">    t1 ^= t0;                                               \</span>
<a name="l01092"></a>01092 <span class="preprocessor">    t1 ^= t0 &gt;&gt; 32 ^ (t1 &lt;&lt; 32 &amp; mask);                     \</span>
<a name="l01093"></a>01093 <span class="preprocessor">    t0 ^=             t0 &lt;&lt; 32 &amp; mask;                      \</span>
<a name="l01094"></a>01094 <span class="preprocessor">    t1 ^= t0 &gt;&gt; 48 ^ (t1 &lt;&lt; 16 &amp; mask);                     \</span>
<a name="l01095"></a>01095 <span class="preprocessor">    t0 ^=             t0 &lt;&lt; 16 &amp; mask;                      \</span>
<a name="l01096"></a>01096 <span class="preprocessor">    statev[I    ] = t0 ^            (t0 &lt;&lt; 8 &amp; mask);       \</span>
<a name="l01097"></a>01097 <span class="preprocessor">    statev[I + 1] = t1 ^ t0 &gt;&gt; 56 ^ (t1 &lt;&lt; 8 &amp; mask);       \</span>
<a name="l01098"></a>01098 <span class="preprocessor">  }</span>
<a name="l01099"></a>01099 <span class="preprocessor"></span>
<a name="l01100"></a>01100   <span class="keyword">template</span>&lt;&gt;
<a name="l01101"></a><a class="code" href="classRandomLib_1_1SFMT19937.html#ac2fc35c6e57afd510b26709292e2c745">01101</a>   <span class="keywordtype">void</span> <a class="code" href="classRandomLib_1_1SFMT19937.html" title="The SFMT random number engine.">SFMT19937&lt;Random_u64&gt;::Transition</a>(<span class="keywordtype">long</span> <span class="keywordtype">long</span> count,
<a name="l01102"></a>01102                                          <a class="code" href="classRandomLib_1_1SFMT19937.html#a0c73ae390b2bbe77f8610a8506b4a896">internal_type</a> statev[])
<a name="l01103"></a>01103     <span class="keywordflow">throw</span>() {
<a name="l01104"></a>01104     <span class="comment">// x[i+N] = g(x[i], x[i+M], x[i+N-2], x[i,N-1])</span>
<a name="l01105"></a>01105     <span class="keywordflow">if</span> (count &gt; 0) {
<a name="l01106"></a>01106       <a class="code" href="classRandomLib_1_1SFMT19937.html#a0c73ae390b2bbe77f8610a8506b4a896">internal_type</a>
<a name="l01107"></a>01107         s0 = statev[N - 4], s1 = statev[N - 3],
<a name="l01108"></a>01108         r0 = statev[N - 2], r1 = statev[N - 1];
<a name="l01109"></a>01109       <span class="keywordflow">for</span> (; count; --count) {
<a name="l01110"></a>01110         <span class="keywordtype">unsigned</span> i = 0;
<a name="l01111"></a>01111         <span class="keywordflow">for</span> (; i + M &lt; N; i += R) <a class="code" href="Random_8cpp.html#aa128846cf5f317e1fbbda2f64fa82d63">SFMT19937_STEP64</a>(i, i + M    );
<a name="l01112"></a>01112         <span class="keywordflow">for</span> (; i &lt; N    ; i += R) <a class="code" href="Random_8cpp.html#aa128846cf5f317e1fbbda2f64fa82d63">SFMT19937_STEP64</a>(i, i + M - N);
<a name="l01113"></a>01113       }
<a name="l01114"></a>01114     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (count &lt; 0)
<a name="l01115"></a>01115       <span class="keywordflow">for</span> (; count; ++count) {
<a name="l01116"></a>01116         <span class="keywordtype">unsigned</span> i = N;
<a name="l01117"></a>01117         <span class="keywordflow">for</span> (; i + M &gt; N;) {
<a name="l01118"></a>01118           i -= R; <a class="code" href="Random_8cpp.html#a1ed27c4ec006a5cdb9728765f370d3e2">SFMT19937_REVSTEP64</a>(i, i + M - N, i - 2 * R, i - R);
<a name="l01119"></a>01119         }
<a name="l01120"></a>01120         <span class="keywordflow">for</span> (; i &gt; 2 * R;) {
<a name="l01121"></a>01121           i -= R; <a class="code" href="Random_8cpp.html#a1ed27c4ec006a5cdb9728765f370d3e2">SFMT19937_REVSTEP64</a>(i, i + M    , i - 2 * R, i - R);
<a name="l01122"></a>01122         }
<a name="l01123"></a>01123         <a class="code" href="Random_8cpp.html#a1ed27c4ec006a5cdb9728765f370d3e2">SFMT19937_REVSTEP64</a>(R, M + R, N -     R, 0    ); <span class="comment">// i = R</span>
<a name="l01124"></a>01124         <a class="code" href="Random_8cpp.html#a1ed27c4ec006a5cdb9728765f370d3e2">SFMT19937_REVSTEP64</a>(0, M    , N - 2 * R, N - R); <span class="comment">// i = 0</span>
<a name="l01125"></a>01125       }
<a name="l01126"></a>01126   }
<a name="l01127"></a>01127 
<a name="l01128"></a>01128 <span class="preprocessor">#undef SFMT19937_STEP64</span>
<a name="l01129"></a>01129 <span class="preprocessor"></span><span class="preprocessor">#undef SFMT19937_REVSTEP64</span>
<a name="l01130"></a>01130 <span class="preprocessor"></span>
<a name="l01131"></a>01131 <span class="preprocessor">#endif  // HAVE_SSE2 and HAVE_ALTIVEC</span>
<a name="l01132"></a>01132 <span class="preprocessor"></span>
<a name="l01133"></a>01133   <span class="keyword">template</span>&lt;&gt;
<a name="l01134"></a><a class="code" href="classRandomLib_1_1SFMT19937.html#a05bf44d27340fcb07913d3d65552d8cf">01134</a>   <span class="keywordtype">void</span> <a class="code" href="classRandomLib_1_1SFMT19937.html" title="The SFMT random number engine.">SFMT19937&lt;Random_u32&gt;::NormalizeState</a>(engine_type state[]) <span class="keywordflow">throw</span>() {
<a name="l01135"></a>01135     <span class="comment">// Carry out the Period Certification for SFMT19937</span>
<a name="l01136"></a>01136     engine_type inner = (state[0] &amp; PARITY0) ^ (state[1] &amp; PARITY1) ^
<a name="l01137"></a>01137       (state[2] &amp; PARITY2) ^ (state[3] &amp; PARITY3);
<a name="l01138"></a>01138     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> s = 16; s; s &gt;&gt;= 1)
<a name="l01139"></a>01139       inner ^= inner &gt;&gt; s;
<a name="l01140"></a>01140     <a class="code" href="Random_8hpp.html#a8f24445c1bccd69b63e365aa5d5bb129">STATIC_ASSERT</a>(PARITY_LSB &lt; 32 &amp;&amp; PARITY0 &amp; 1u &lt;&lt; PARITY_LSB,
<a name="l01141"></a>01141                   <span class="stringliteral">&quot;inconsistent PARITY_LSB or PARITY0&quot;</span>);
<a name="l01142"></a>01142     <span class="comment">// Now inner &amp; 1 is the parity of the number of 1 bits in w_0 &amp; p.</span>
<a name="l01143"></a>01143     <span class="keywordflow">if</span> ((inner &amp; 1u) == 0)
<a name="l01144"></a>01144       <span class="comment">// Change bit of w_0 corresponding to LSB of PARITY</span>
<a name="l01145"></a>01145       state[PARITY_LSB &gt;&gt; 5] ^= engine_type(1u) &lt;&lt; (PARITY_LSB &amp; 31u);
<a name="l01146"></a>01146   }
<a name="l01147"></a>01147 
<a name="l01148"></a>01148   <span class="keyword">template</span>&lt;&gt;
<a name="l01149"></a><a class="code" href="classRandomLib_1_1SFMT19937.html#a3aab082f4d15e95480a17a5b73ac66d6">01149</a>   <span class="keywordtype">void</span> <a class="code" href="classRandomLib_1_1SFMT19937.html" title="The SFMT random number engine.">SFMT19937&lt;Random_u64&gt;::NormalizeState</a>(engine_type state[]) <span class="keywordflow">throw</span>() {
<a name="l01150"></a>01150     <span class="comment">// Carry out the Period Certification for SFMT19937</span>
<a name="l01151"></a>01151     engine_type inner = (state[0] &amp; PARITY0) ^ (state[1] &amp; PARITY1);
<a name="l01152"></a>01152     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> s = 32; s; s &gt;&gt;= 1)
<a name="l01153"></a>01153       inner ^= inner &gt;&gt; s;
<a name="l01154"></a>01154     <a class="code" href="Random_8hpp.html#a8f24445c1bccd69b63e365aa5d5bb129">STATIC_ASSERT</a>(PARITY_LSB &lt; 64 &amp;&amp; PARITY0 &amp; 1u &lt;&lt; PARITY_LSB,
<a name="l01155"></a>01155                   <span class="stringliteral">&quot;inconsistent PARITY_LSB or PARITY0&quot;</span>);
<a name="l01156"></a>01156     <span class="comment">// Now inner &amp; 1 is the parity of the number of 1 bits in w_0 &amp; p.</span>
<a name="l01157"></a>01157     <span class="keywordflow">if</span> ((inner &amp; 1u) == 0)
<a name="l01158"></a>01158       <span class="comment">// Change bit of w_0 corresponding to LSB of PARITY</span>
<a name="l01159"></a>01159       state[PARITY_LSB &gt;&gt; 6] ^= engine_type(1u) &lt;&lt; (PARITY_LSB &amp; 63u);
<a name="l01160"></a>01160   }
<a name="l01161"></a>01161 
<a name="l01162"></a>01162   <span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomType&gt;
<a name="l01163"></a><a class="code" href="classRandomLib_1_1SFMT19937.html#a622696238696656323bc464f37e38911">01163</a>   <span class="keywordtype">void</span> <a class="code" href="classRandomLib_1_1SFMT19937.html" title="The SFMT random number engine.">SFMT19937&lt;RandomType&gt;::CheckState</a>(<span class="keyword">const</span> engine_type state[],
<a name="l01164"></a>01164                                          <a class="code" href="classRandomLib_1_1RandomType.html#a99d4e836129ffa9171bc94375ff98546">Random_u32::type</a>&amp; check) {
<a name="l01165"></a>01165     engine_type x = 0;
<a name="l01166"></a>01166     <a class="code" href="classRandomLib_1_1RandomType.html#a99d4e836129ffa9171bc94375ff98546">Random_u32::type</a> c = check;
<a name="l01167"></a>01167     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; N; ++i) {
<a name="l01168"></a>01168       engine_t::CheckSum(state[i], c);
<a name="l01169"></a>01169       x |= state[i];
<a name="l01170"></a>01170     }
<a name="l01171"></a>01171     <span class="keywordflow">if</span> (x == 0)
<a name="l01172"></a>01172       <span class="keywordflow">throw</span> <a class="code" href="classRandomLib_1_1RandomErr.html" title="Exception handling for RandomLib.">RandomErr</a>(<span class="stringliteral">&quot;SFMT19937: All-zero state&quot;</span>);
<a name="l01173"></a>01173     check = c;
<a name="l01174"></a>01174   }
<a name="l01175"></a>01175 
<a name="l01176"></a>01176   <span class="comment">// RandomPower2 implementation</span>
<a name="l01177"></a>01177 
<a name="l01178"></a>01178 <span class="preprocessor">#if RANDOMLIB_POWERTABLE</span>
<a name="l01179"></a>01179 <span class="preprocessor"></span>  <span class="comment">// Powers of two.  Just use floats here.  As long as there&#39;s no overflow</span>
<a name="l01180"></a>01180   <span class="comment">// or underflow these are exact.  In particular they can be cast to</span>
<a name="l01181"></a>01181   <span class="comment">// doubles or long doubles with no error.</span>
<a name="l01182"></a>01182   <span class="keyword">const</span> <span class="keywordtype">float</span> RandomPower2::power2[maxpow - minpow + 1] = {
<a name="l01183"></a>01183 <span class="preprocessor">#if RANDOMLIB_LONGDOUBLEPREC &gt; 64</span>
<a name="l01184"></a>01184 <span class="preprocessor"></span>    <span class="comment">// It would be nice to be able to use the C99 notation of 0x1.0p-120</span>
<a name="l01185"></a>01185     <span class="comment">// for 2^-120 here.</span>
<a name="l01186"></a>01186     1/1329227995784915872903807060280344576.f, <span class="comment">// 2^-120</span>
<a name="l01187"></a>01187     1/664613997892457936451903530140172288.f,  <span class="comment">// 2^-119</span>
<a name="l01188"></a>01188     1/332306998946228968225951765070086144.f,  <span class="comment">// 2^-118</span>
<a name="l01189"></a>01189     1/166153499473114484112975882535043072.f,  <span class="comment">// 2^-117</span>
<a name="l01190"></a>01190     1/83076749736557242056487941267521536.f,   <span class="comment">// 2^-116</span>
<a name="l01191"></a>01191     1/41538374868278621028243970633760768.f,   <span class="comment">// 2^-115</span>
<a name="l01192"></a>01192     1/20769187434139310514121985316880384.f,   <span class="comment">// 2^-114</span>
<a name="l01193"></a>01193     1/10384593717069655257060992658440192.f,   <span class="comment">// 2^-113</span>
<a name="l01194"></a>01194     1/5192296858534827628530496329220096.f,    <span class="comment">// 2^-112</span>
<a name="l01195"></a>01195     1/2596148429267413814265248164610048.f,    <span class="comment">// 2^-111</span>
<a name="l01196"></a>01196     1/1298074214633706907132624082305024.f,    <span class="comment">// 2^-110</span>
<a name="l01197"></a>01197     1/649037107316853453566312041152512.f,     <span class="comment">// 2^-109</span>
<a name="l01198"></a>01198     1/324518553658426726783156020576256.f,     <span class="comment">// 2^-108</span>
<a name="l01199"></a>01199     1/162259276829213363391578010288128.f,     <span class="comment">// 2^-107</span>
<a name="l01200"></a>01200     1/81129638414606681695789005144064.f,      <span class="comment">// 2^-106</span>
<a name="l01201"></a>01201     1/40564819207303340847894502572032.f,      <span class="comment">// 2^-105</span>
<a name="l01202"></a>01202     1/20282409603651670423947251286016.f,      <span class="comment">// 2^-104</span>
<a name="l01203"></a>01203     1/10141204801825835211973625643008.f,      <span class="comment">// 2^-103</span>
<a name="l01204"></a>01204     1/5070602400912917605986812821504.f,       <span class="comment">// 2^-102</span>
<a name="l01205"></a>01205     1/2535301200456458802993406410752.f,       <span class="comment">// 2^-101</span>
<a name="l01206"></a>01206     1/1267650600228229401496703205376.f,       <span class="comment">// 2^-100</span>
<a name="l01207"></a>01207     1/633825300114114700748351602688.f,        <span class="comment">// 2^-99</span>
<a name="l01208"></a>01208     1/316912650057057350374175801344.f,        <span class="comment">// 2^-98</span>
<a name="l01209"></a>01209     1/158456325028528675187087900672.f,        <span class="comment">// 2^-97</span>
<a name="l01210"></a>01210     1/79228162514264337593543950336.f,         <span class="comment">// 2^-96</span>
<a name="l01211"></a>01211     1/39614081257132168796771975168.f,         <span class="comment">// 2^-95</span>
<a name="l01212"></a>01212     1/19807040628566084398385987584.f,         <span class="comment">// 2^-94</span>
<a name="l01213"></a>01213     1/9903520314283042199192993792.f,          <span class="comment">// 2^-93</span>
<a name="l01214"></a>01214     1/4951760157141521099596496896.f,          <span class="comment">// 2^-92</span>
<a name="l01215"></a>01215     1/2475880078570760549798248448.f,          <span class="comment">// 2^-91</span>
<a name="l01216"></a>01216     1/1237940039285380274899124224.f,          <span class="comment">// 2^-90</span>
<a name="l01217"></a>01217     1/618970019642690137449562112.f,           <span class="comment">// 2^-89</span>
<a name="l01218"></a>01218     1/309485009821345068724781056.f,           <span class="comment">// 2^-88</span>
<a name="l01219"></a>01219     1/154742504910672534362390528.f,           <span class="comment">// 2^-87</span>
<a name="l01220"></a>01220     1/77371252455336267181195264.f,            <span class="comment">// 2^-86</span>
<a name="l01221"></a>01221     1/38685626227668133590597632.f,            <span class="comment">// 2^-85</span>
<a name="l01222"></a>01222     1/19342813113834066795298816.f,            <span class="comment">// 2^-84</span>
<a name="l01223"></a>01223     1/9671406556917033397649408.f,             <span class="comment">// 2^-83</span>
<a name="l01224"></a>01224     1/4835703278458516698824704.f,             <span class="comment">// 2^-82</span>
<a name="l01225"></a>01225     1/2417851639229258349412352.f,             <span class="comment">// 2^-81</span>
<a name="l01226"></a>01226     1/1208925819614629174706176.f,             <span class="comment">// 2^-80</span>
<a name="l01227"></a>01227     1/604462909807314587353088.f,              <span class="comment">// 2^-79</span>
<a name="l01228"></a>01228     1/302231454903657293676544.f,              <span class="comment">// 2^-78</span>
<a name="l01229"></a>01229     1/151115727451828646838272.f,              <span class="comment">// 2^-77</span>
<a name="l01230"></a>01230     1/75557863725914323419136.f,               <span class="comment">// 2^-76</span>
<a name="l01231"></a>01231     1/37778931862957161709568.f,               <span class="comment">// 2^-75</span>
<a name="l01232"></a>01232     1/18889465931478580854784.f,               <span class="comment">// 2^-74</span>
<a name="l01233"></a>01233     1/9444732965739290427392.f,                <span class="comment">// 2^-73</span>
<a name="l01234"></a>01234     1/4722366482869645213696.f,                <span class="comment">// 2^-72</span>
<a name="l01235"></a>01235     1/2361183241434822606848.f,                <span class="comment">// 2^-71</span>
<a name="l01236"></a>01236     1/1180591620717411303424.f,                <span class="comment">// 2^-70</span>
<a name="l01237"></a>01237     1/590295810358705651712.f,                 <span class="comment">// 2^-69</span>
<a name="l01238"></a>01238     1/295147905179352825856.f,                 <span class="comment">// 2^-68</span>
<a name="l01239"></a>01239     1/147573952589676412928.f,                 <span class="comment">// 2^-67</span>
<a name="l01240"></a>01240     1/73786976294838206464.f,                  <span class="comment">// 2^-66</span>
<a name="l01241"></a>01241     1/36893488147419103232.f,                  <span class="comment">// 2^-65</span>
<a name="l01242"></a>01242 <span class="preprocessor">#endif</span>
<a name="l01243"></a>01243 <span class="preprocessor"></span>    1/18446744073709551616.f,   <span class="comment">// 2^-64</span>
<a name="l01244"></a>01244     1/9223372036854775808.f,    <span class="comment">// 2^-63</span>
<a name="l01245"></a>01245     1/4611686018427387904.f,    <span class="comment">// 2^-62</span>
<a name="l01246"></a>01246     1/2305843009213693952.f,    <span class="comment">// 2^-61</span>
<a name="l01247"></a>01247     1/1152921504606846976.f,    <span class="comment">// 2^-60</span>
<a name="l01248"></a>01248     1/576460752303423488.f,     <span class="comment">// 2^-59</span>
<a name="l01249"></a>01249     1/288230376151711744.f,     <span class="comment">// 2^-58</span>
<a name="l01250"></a>01250     1/144115188075855872.f,     <span class="comment">// 2^-57</span>
<a name="l01251"></a>01251     1/72057594037927936.f,      <span class="comment">// 2^-56</span>
<a name="l01252"></a>01252     1/36028797018963968.f,      <span class="comment">// 2^-55</span>
<a name="l01253"></a>01253     1/18014398509481984.f,      <span class="comment">// 2^-54</span>
<a name="l01254"></a>01254     1/9007199254740992.f,       <span class="comment">// 2^-53</span>
<a name="l01255"></a>01255     1/4503599627370496.f,       <span class="comment">// 2^-52</span>
<a name="l01256"></a>01256     1/2251799813685248.f,       <span class="comment">// 2^-51</span>
<a name="l01257"></a>01257     1/1125899906842624.f,       <span class="comment">// 2^-50</span>
<a name="l01258"></a>01258     1/562949953421312.f,        <span class="comment">// 2^-49</span>
<a name="l01259"></a>01259     1/281474976710656.f,        <span class="comment">// 2^-48</span>
<a name="l01260"></a>01260     1/140737488355328.f,        <span class="comment">// 2^-47</span>
<a name="l01261"></a>01261     1/70368744177664.f,         <span class="comment">// 2^-46</span>
<a name="l01262"></a>01262     1/35184372088832.f,         <span class="comment">// 2^-45</span>
<a name="l01263"></a>01263     1/17592186044416.f,         <span class="comment">// 2^-44</span>
<a name="l01264"></a>01264     1/8796093022208.f,          <span class="comment">// 2^-43</span>
<a name="l01265"></a>01265     1/4398046511104.f,          <span class="comment">// 2^-42</span>
<a name="l01266"></a>01266     1/2199023255552.f,          <span class="comment">// 2^-41</span>
<a name="l01267"></a>01267     1/1099511627776.f,          <span class="comment">// 2^-40</span>
<a name="l01268"></a>01268     1/549755813888.f,           <span class="comment">// 2^-39</span>
<a name="l01269"></a>01269     1/274877906944.f,           <span class="comment">// 2^-38</span>
<a name="l01270"></a>01270     1/137438953472.f,           <span class="comment">// 2^-37</span>
<a name="l01271"></a>01271     1/68719476736.f,            <span class="comment">// 2^-36</span>
<a name="l01272"></a>01272     1/34359738368.f,            <span class="comment">// 2^-35</span>
<a name="l01273"></a>01273     1/17179869184.f,            <span class="comment">// 2^-34</span>
<a name="l01274"></a>01274     1/8589934592.f,             <span class="comment">// 2^-33</span>
<a name="l01275"></a>01275     1/4294967296.f,             <span class="comment">// 2^-32</span>
<a name="l01276"></a>01276     1/2147483648.f,             <span class="comment">// 2^-31</span>
<a name="l01277"></a>01277     1/1073741824.f,             <span class="comment">// 2^-30</span>
<a name="l01278"></a>01278     1/536870912.f,              <span class="comment">// 2^-29</span>
<a name="l01279"></a>01279     1/268435456.f,              <span class="comment">// 2^-28</span>
<a name="l01280"></a>01280     1/134217728.f,              <span class="comment">// 2^-27</span>
<a name="l01281"></a>01281     1/67108864.f,               <span class="comment">// 2^-26</span>
<a name="l01282"></a>01282     1/33554432.f,               <span class="comment">// 2^-25</span>
<a name="l01283"></a>01283     1/16777216.f,               <span class="comment">// 2^-24</span>
<a name="l01284"></a>01284     1/8388608.f,                <span class="comment">// 2^-23</span>
<a name="l01285"></a>01285     1/4194304.f,                <span class="comment">// 2^-22</span>
<a name="l01286"></a>01286     1/2097152.f,                <span class="comment">// 2^-21</span>
<a name="l01287"></a>01287     1/1048576.f,                <span class="comment">// 2^-20</span>
<a name="l01288"></a>01288     1/524288.f,                 <span class="comment">// 2^-19</span>
<a name="l01289"></a>01289     1/262144.f,                 <span class="comment">// 2^-18</span>
<a name="l01290"></a>01290     1/131072.f,                 <span class="comment">// 2^-17</span>
<a name="l01291"></a>01291     1/65536.f,                  <span class="comment">// 2^-16</span>
<a name="l01292"></a>01292     1/32768.f,                  <span class="comment">// 2^-15</span>
<a name="l01293"></a>01293     1/16384.f,                  <span class="comment">// 2^-14</span>
<a name="l01294"></a>01294     1/8192.f,                   <span class="comment">// 2^-13</span>
<a name="l01295"></a>01295     1/4096.f,                   <span class="comment">// 2^-12</span>
<a name="l01296"></a>01296     1/2048.f,                   <span class="comment">// 2^-11</span>
<a name="l01297"></a>01297     1/1024.f,                   <span class="comment">// 2^-10</span>
<a name="l01298"></a>01298     1/512.f,                    <span class="comment">// 2^-9</span>
<a name="l01299"></a>01299     1/256.f,                    <span class="comment">// 2^-8</span>
<a name="l01300"></a>01300     1/128.f,                    <span class="comment">// 2^-7</span>
<a name="l01301"></a>01301     1/64.f,                     <span class="comment">// 2^-6</span>
<a name="l01302"></a>01302     1/32.f,                     <span class="comment">// 2^-5</span>
<a name="l01303"></a>01303     1/16.f,                     <span class="comment">// 2^-4</span>
<a name="l01304"></a>01304     1/8.f,                      <span class="comment">// 2^-3</span>
<a name="l01305"></a>01305     1/4.f,                      <span class="comment">// 2^-2</span>
<a name="l01306"></a>01306     1/2.f,                      <span class="comment">// 2^-1</span>
<a name="l01307"></a>01307     1.f,                        <span class="comment">// 2^0</span>
<a name="l01308"></a>01308     2.f,                        <span class="comment">// 2^1</span>
<a name="l01309"></a>01309     4.f,                        <span class="comment">// 2^2</span>
<a name="l01310"></a>01310     8.f,                        <span class="comment">// 2^3</span>
<a name="l01311"></a>01311     16.f,                       <span class="comment">// 2^4</span>
<a name="l01312"></a>01312     32.f,                       <span class="comment">// 2^5</span>
<a name="l01313"></a>01313     64.f,                       <span class="comment">// 2^6</span>
<a name="l01314"></a>01314     128.f,                      <span class="comment">// 2^7</span>
<a name="l01315"></a>01315     256.f,                      <span class="comment">// 2^8</span>
<a name="l01316"></a>01316     512.f,                      <span class="comment">// 2^9</span>
<a name="l01317"></a>01317     1024.f,                     <span class="comment">// 2^10</span>
<a name="l01318"></a>01318     2048.f,                     <span class="comment">// 2^11</span>
<a name="l01319"></a>01319     4096.f,                     <span class="comment">// 2^12</span>
<a name="l01320"></a>01320     8192.f,                     <span class="comment">// 2^13</span>
<a name="l01321"></a>01321     16384.f,                    <span class="comment">// 2^14</span>
<a name="l01322"></a>01322     32768.f,                    <span class="comment">// 2^15</span>
<a name="l01323"></a>01323     65536.f,                    <span class="comment">// 2^16</span>
<a name="l01324"></a>01324     131072.f,                   <span class="comment">// 2^17</span>
<a name="l01325"></a>01325     262144.f,                   <span class="comment">// 2^18</span>
<a name="l01326"></a>01326     524288.f,                   <span class="comment">// 2^19</span>
<a name="l01327"></a>01327     1048576.f,                  <span class="comment">// 2^20</span>
<a name="l01328"></a>01328     2097152.f,                  <span class="comment">// 2^21</span>
<a name="l01329"></a>01329     4194304.f,                  <span class="comment">// 2^22</span>
<a name="l01330"></a>01330     8388608.f,                  <span class="comment">// 2^23</span>
<a name="l01331"></a>01331     16777216.f,                 <span class="comment">// 2^24</span>
<a name="l01332"></a>01332     33554432.f,                 <span class="comment">// 2^25</span>
<a name="l01333"></a>01333     67108864.f,                 <span class="comment">// 2^26</span>
<a name="l01334"></a>01334     134217728.f,                <span class="comment">// 2^27</span>
<a name="l01335"></a>01335     268435456.f,                <span class="comment">// 2^28</span>
<a name="l01336"></a>01336     536870912.f,                <span class="comment">// 2^29</span>
<a name="l01337"></a>01337     1073741824.f,               <span class="comment">// 2^30</span>
<a name="l01338"></a>01338     2147483648.f,               <span class="comment">// 2^31</span>
<a name="l01339"></a>01339     4294967296.f,               <span class="comment">// 2^32</span>
<a name="l01340"></a>01340     8589934592.f,               <span class="comment">// 2^33</span>
<a name="l01341"></a>01341     17179869184.f,              <span class="comment">// 2^34</span>
<a name="l01342"></a>01342     34359738368.f,              <span class="comment">// 2^35</span>
<a name="l01343"></a>01343     68719476736.f,              <span class="comment">// 2^36</span>
<a name="l01344"></a>01344     137438953472.f,             <span class="comment">// 2^37</span>
<a name="l01345"></a>01345     274877906944.f,             <span class="comment">// 2^38</span>
<a name="l01346"></a>01346     549755813888.f,             <span class="comment">// 2^39</span>
<a name="l01347"></a>01347     1099511627776.f,            <span class="comment">// 2^40</span>
<a name="l01348"></a>01348     2199023255552.f,            <span class="comment">// 2^41</span>
<a name="l01349"></a>01349     4398046511104.f,            <span class="comment">// 2^42</span>
<a name="l01350"></a>01350     8796093022208.f,            <span class="comment">// 2^43</span>
<a name="l01351"></a>01351     17592186044416.f,           <span class="comment">// 2^44</span>
<a name="l01352"></a>01352     35184372088832.f,           <span class="comment">// 2^45</span>
<a name="l01353"></a>01353     70368744177664.f,           <span class="comment">// 2^46</span>
<a name="l01354"></a>01354     140737488355328.f,          <span class="comment">// 2^47</span>
<a name="l01355"></a>01355     281474976710656.f,          <span class="comment">// 2^48</span>
<a name="l01356"></a>01356     562949953421312.f,          <span class="comment">// 2^49</span>
<a name="l01357"></a>01357     1125899906842624.f,         <span class="comment">// 2^50</span>
<a name="l01358"></a>01358     2251799813685248.f,         <span class="comment">// 2^51</span>
<a name="l01359"></a>01359     4503599627370496.f,         <span class="comment">// 2^52</span>
<a name="l01360"></a>01360     9007199254740992.f,         <span class="comment">// 2^53</span>
<a name="l01361"></a>01361     18014398509481984.f,        <span class="comment">// 2^54</span>
<a name="l01362"></a>01362     36028797018963968.f,        <span class="comment">// 2^55</span>
<a name="l01363"></a>01363     72057594037927936.f,        <span class="comment">// 2^56</span>
<a name="l01364"></a>01364     144115188075855872.f,       <span class="comment">// 2^57</span>
<a name="l01365"></a>01365     288230376151711744.f,       <span class="comment">// 2^58</span>
<a name="l01366"></a>01366     576460752303423488.f,       <span class="comment">// 2^59</span>
<a name="l01367"></a>01367     1152921504606846976.f,      <span class="comment">// 2^60</span>
<a name="l01368"></a>01368     2305843009213693952.f,      <span class="comment">// 2^61</span>
<a name="l01369"></a>01369     4611686018427387904.f,      <span class="comment">// 2^62</span>
<a name="l01370"></a>01370     9223372036854775808.f,      <span class="comment">// 2^63</span>
<a name="l01371"></a>01371     18446744073709551616.f,     <span class="comment">// 2^64</span>
<a name="l01372"></a>01372   };
<a name="l01373"></a>01373 <span class="preprocessor">#endif</span>
<a name="l01374"></a>01374 <span class="preprocessor"></span>
<a name="l01375"></a>01375   <span class="comment">// RandomEngine (and implicitly RandomAlgorithm and RandomMixer)</span>
<a name="l01376"></a>01376   <span class="comment">// instantiations.  The first 4 (using MixerMT[01]) are not recommended.</span>
<a name="l01377"></a>01377   <span class="keyword">template</span> <span class="keyword">class </span>RandomEngine&lt;  MT19937&lt;Random_u32&gt;, MixerMT0&lt;Random_u32&gt; &gt;;
<a name="l01378"></a>01378   <span class="keyword">template</span> <span class="keyword">class </span>RandomEngine&lt;  MT19937&lt;Random_u64&gt;, MixerMT0&lt;Random_u64&gt; &gt;;
<a name="l01379"></a>01379   <span class="keyword">template</span> <span class="keyword">class </span>RandomEngine&lt;  MT19937&lt;Random_u32&gt;, MixerMT1&lt;Random_u32&gt; &gt;;
<a name="l01380"></a>01380   <span class="keyword">template</span> <span class="keyword">class </span>RandomEngine&lt;  MT19937&lt;Random_u64&gt;, MixerMT1&lt;Random_u64&gt; &gt;;
<a name="l01381"></a>01381 
<a name="l01382"></a>01382   <span class="keyword">template</span> <span class="keyword">class </span>RandomEngine&lt;  MT19937&lt;Random_u32&gt;, MixerSFMT&gt;;
<a name="l01383"></a>01383   <span class="keyword">template</span> <span class="keyword">class </span>RandomEngine&lt;  MT19937&lt;Random_u64&gt;, MixerSFMT&gt;;
<a name="l01384"></a>01384   <span class="keyword">template</span> <span class="keyword">class </span>RandomEngine&lt;SFMT19937&lt;Random_u32&gt;, MixerSFMT&gt;;
<a name="l01385"></a>01385   <span class="keyword">template</span> <span class="keyword">class </span>RandomEngine&lt;SFMT19937&lt;Random_u64&gt;, MixerSFMT&gt;;
<a name="l01386"></a>01386 
<a name="l01387"></a>01387   <span class="comment">// RandomCanonial instantiations</span>
<a name="l01388"></a>01388 
<a name="l01389"></a>01389   <span class="keyword">template</span>&lt;&gt; RandomCanonical&lt;MRandomGenerator32&gt;
<a name="l01390"></a><a class="code" href="classRandomLib_1_1RandomCanonical.html#a708577f0b6d591de679745817b19d0cc">01390</a>   <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomCanonical&lt;MRandomGenerator32&gt;::Global</a> = <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomCanonical</a>();
<a name="l01391"></a>01391   <span class="keyword">template</span>&lt;&gt; <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomCanonical&lt;MRandomGenerator64&gt;</a>
<a name="l01392"></a><a class="code" href="classRandomLib_1_1RandomCanonical.html#a6c78498b8d6814d2d32aed69bea2b5d7">01392</a>   <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomCanonical&lt;MRandomGenerator64&gt;::Global</a> = <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomCanonical</a>();
<a name="l01393"></a>01393   <span class="keyword">template</span>&lt;&gt; <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomCanonical&lt;SRandomGenerator32&gt;</a>
<a name="l01394"></a><a class="code" href="classRandomLib_1_1RandomCanonical.html#a0e421c4ac37b584cf2c4c10ea10ea5f5">01394</a>   <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomCanonical&lt;SRandomGenerator32&gt;::Global</a> = <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomCanonical</a>();
<a name="l01395"></a>01395   <span class="keyword">template</span>&lt;&gt; <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomCanonical&lt;SRandomGenerator64&gt;</a>
<a name="l01396"></a><a class="code" href="classRandomLib_1_1RandomCanonical.html#ab0ec4b3da2e609a5d3d763cdbf697b60">01396</a>   <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomCanonical&lt;SRandomGenerator64&gt;::Global</a> = <a class="code" href="classRandomLib_1_1RandomCanonical.html" title="Generate random integers, reals, and booleans.">RandomCanonical</a>();
<a name="l01397"></a>01397 
<a name="l01398"></a>01398 } <span class="comment">// namespace RandomLib</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sat Jan 21 2012 for RandomLib by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
