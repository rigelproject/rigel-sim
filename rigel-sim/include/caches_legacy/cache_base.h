////////////////////////////////////////////////////////////////////////////////
// includes/caches/cache_base.h
////////////////////////////////////////////////////////////////////////////////
//
//  This file contains the definition of the base class for all of the caches in
//  the simulator.  This file is included from cache_model.h.
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __CACHES__CACHE_BASE__
#define __CACHES__CACHE_BASE__

#include "util/dynamic_bitset.h"
#include "caches_legacy/cache_tags.h"
#include "mshr.h"

////////////////////////////////////////////////////////////////////////////////
/// CacheBase
/// All of the caches are derived from CacheBase include L1I, L1D, L2D, L2I, and
/// the global caches.  The only methods that generally have to be specialized
/// are the Fill(), PerCycle(), evict(), pend(), and Schedule() methods.  The
/// get_set() method is virtual to allow it to be specialized for the global
/// cache.
////////////////////////////////////////////////////////////////////////////////

class InstrLegacy;
template<int T> class MissHandlingEntry;

////////////////////////////////////////////////////////////////////////////////
// Class CacheAccess_t
////////////////////////////////////////////////////////////////////////////////
// data packet for tracking cache access requests
class CacheAccess_t {

  //////////////////////////////////////////////////////////////////////////////
  // Private Data Members
  //////////////////////////////////////////////////////////////////////////////
  private:

  uint32_t _addr;           // address of request //FIXME should not need _addr and _addrs
  int _core_id;             // core number
  int _tid;                 // thread id
  icmsg_type_t _icmsg_type; // interconnect message type
  InstrLegacy*   _instr;      // pointer to instruction correlated to this access,
                            // if any (may not be tied to particular isntr)
  // Set if the access was generated by a nonblocking atomic.  Should be false
  // otherwise.
  bool nonblocking_atomic;
  std::set<uint32_t> _addrs;          // List of all addresses (FIXME need to figure out
                                      // how best to integrate this)
  // Set if the BCAST_REQ initiating *this* BCAST_REP was to a line valid in the L2.
  bool bcast_was_valid;
  //////////////////////////////////////////////////////////////////////////////
  // Public Methods
  //////////////////////////////////////////////////////////////////////////////
  public:

  // constructors
  CacheAccess_t(); // default
  CacheAccess_t(
    uint32_t addr, int core, int tid, icmsg_type_t icmsg_type, InstrLegacy* instr) :
             _addr(        addr       ),
             _core_id(     core       ),
             _tid(         tid        ),
             _icmsg_type(  icmsg_type ),
             _instr(       instr      ),
             nonblocking_atomic(false),
             _addrs(),
             bcast_was_valid(false) { _addrs.insert(addr); }

  CacheAccess_t(
    const std::set<uint32_t> &addrs, int core, int tid, icmsg_type_t icmsg_type,
    InstrLegacy* instr) : _addr(*(addrs.begin())),
                        _core_id(core),
                        _tid(tid),
                        _icmsg_type(icmsg_type),
                        _instr(instr),
                        nonblocking_atomic(false),
                        _addrs(addrs),
                        bcast_was_valid(false) { }
              
  //////////////////////////////////////////////////////////////////////////////
  // get accessors
  //////////////////////////////////////////////////////////////////////////////
  // FIXME: make all these check if internal value is VALID before returning!
  // use the msg type to determine if a subfield should be accessible?
  uint32_t get_addr() const { return _addr; }
  std::set<uint32_t> const &get_addrs() const { return _addrs; }
  const std::set<uint32_t>::const_iterator get_addrs_begin() const { return _addrs.begin(); }
  const std::set<uint32_t>::const_iterator get_addrs_end() const { return _addrs.end(); } 
  int get_core_id() const {
    //assert( _core_id >= 0 && "Invalid Core number");
    return _core_id;
  };
  int get_tid() const {
    //if( _tid < 0 ) { fprintf(stderr, "Illegal tid (%d) in CCacheAccess_t \n",_tid); }
    //assert( _tid >=0 && "Invalid ThreadID");
    return _tid;
  };
  icmsg_type_t get_icmsg_type() const {
    //assert( _icmsg_type != IC_MSG_ERROR && "attempting to read invalid message type" );
    return _icmsg_type;
  };
  InstrLegacy* get_instr() const {
    // FIXME this assertion seems too agressive, or our discipline for accessing when
    // Null is to check in the accessing function?
    //assert( _instr != rigel::NullInstr &&
    //  "attempting to access invalid instr field (NullInstr) of cache_access_t!");
    return _instr;
  }
  bool get_nonblocking_atomic() const { return nonblocking_atomic; }
  bool get_bcast_resp_valid() const { return bcast_was_valid; }
  // end get accessors
  //////////////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////////////
  // set accessors
  //////////////////////////////////////////////////////////////////////////////
  void set_core_id( int      c ) { _core_id = c; }
  void set_tid(     int      t ) { _tid     = t; }
  void set_addr(    uint32_t a ) { _addrs.clear(); _addrs.insert(a); _addr = a; }
  void add_addr(    uint32_t a ) { _addrs.insert(a); }
  template<class InputIterator> void add_addrs( InputIterator begin, InputIterator end)
  {
    _addrs.insert(begin, end);
  }
  void set_icmsg_type( icmsg_type_t i ) { _icmsg_type = i; }
  void set_instr     ( InstrLegacy*   i ) { _instr      = i; }
  void set_nonblocking_atomic(bool atomic = true) { nonblocking_atomic = atomic; }
  void set_bcast_resp_valid() { bcast_was_valid = true; }
  void clear_bcast_resp_valid() { bcast_was_valid = false; }
  // end set accessors
  //////////////////////////////////////////////////////////////////////////////
};
// end Class CacheAccess_t
////////////////////////////////////////////////////////////////////////////////

#define CACHE_TEMPLATE \
template < \
 int ways, \
 int sets, \
 int linesize, \
 int MAX_OUTSTANDING_MISSES, \
 int WB_POLICY, \
 int CACHE_EVICTION_BUFFER_SIZE \
>

template <
  int ways, int sets, int linesize,
  int MAX_OUTSTANDING_MISSES, int WB_POLICY, int CACHE_EVICTION_BUFFER_SIZE
>
class CacheBase
{

  public: /* ACCESSORS */
    // Default constructor
    CacheBase ();
    virtual ~CacheBase () { };

    void PM_set_acked(int i) { pendingMiss[i].SetRequestAcked(); }
    // Sanity check to make sure we are actually using our cache effectively
    uint32_t get_insert_count(int set, int way) { return (TagArray[set][way].insert_count()); }
    uint32_t get_touch_count(int set, int way) { return (TagArray[set][way].touch_count()); }
    // Change the coherence state of a line in the cache.
    void set_coherence_state(uint32_t addr, coherence_state_t state);
    // Returns true if the line has been accessed while it has been in the
    // cache, false otherwise.
    bool get_accessed_bit(uint32_t addr) const;
    void set_accessed_bit_read(uint32_t addr);
    void set_accessed_bit_write(uint32_t addr);

  //private: /* ACCESSORS */
  //protected: /* ACCESSORS */
  public:
    // Called once at begining of cycle by the cache model.
    void PerCycle();
    // Return the set for the address.
    virtual int get_set(uint32_t addr) const
      { int set = ((addr >> SET_SHIFT) & SET_MASK); return set; };

    //Returns pointer to matching, valid MSHR if it exists, NULL otherwise.
    virtual MissHandlingEntry<linesize> * IsPending(uint32_t addr)
    {
      addr &= rigel::cache::LINE_MASK;
      int i = validBits.findFirstSet();
      while(i != -1)
      {
        if(pendingMiss[i].check_valid(addr))
          return &(pendingMiss[i]);
        else
          i = validBits.findNextSet(i);
      }
      // Not pending
      return NULL;
    };

    // get_set, get_way_word, get_way_line
    // Returns way number based on whether a particular word if found, -1 if not
    // found.  The line may be valid, but the particular word is not.
    int get_way_word(uint32_t addr) const;
    // Optimization for when set is already calculated
    int get_way_word(uint32_t addr, int set) const;
    // Return way number if the line is present (any valid bits set).  The
    // particular word requested may not be available. Returns -1 if nothing
    // found.
    int get_way_line(uint32_t addr) const;
    // Optimization for when set is already calculated
    int get_way_line(uint32_t addr, int set) const;
    //Return whether or not this line is currently
    //being evicted (selected as a victim, but awaiting an MSHR or something else).
    // NOTE:
    // If a line is being evicted, but is waiting on an MSHR for whatever reason,
    // we don't want subsequent accesses to that line to be able to grab an MSHR first,
    // because then the subsequent access could bypass the eviction and you'd get the
    // wrong value.  We need to call is_being_evicted() in most of the same places as
    // IsPending() to make sure this doesn't happen.  We assume that this can be implemented
    // in hardware by adding a bit to each entry in the tag SRAM denoting whether the way is
    // currently undergoing eviction.  The cache should return a miss and not grab an MSHR if
    // the bit is set.  The other possible solution to this problem is to make sure that evictions
    // can never stall waiting for an MSHR, so subsequent accesses can never bypass them, but that
    // seems like it'd require a lot of MSHRs.
    bool is_being_evicted(uint32_t addr) const;
    // returns true if all MSHRs are full
    bool mshr_full(bool = false);
    // Update LRU info in the cache
    void touch(uint32_t addr);
    // Clear HW prefetch bit for line.
    void ClearHWPrefetch(uint32_t addr);
    // Query HW prefetch bit for line.
    bool IsHWPrefetch(uint32_t addr);
    // Clear bulk prefetch bit for line.
    void ClearBulkPrefetch(uint32_t addr);
    // Query bulk prefetch bit for line.
    bool IsBulkPrefetch(uint32_t addr);
    // Get the proper word bit for the address.
    static uint32_t getWordBitsForLine(uint32_t addr);
    // Set word valid on a line that is already valid in the cache.
    void setValidWord(uint32_t addr);
    // Return the words that are valid for a line as a bitmask.
    uint32_t getValidMask(uint32_t addr);
    // Dirty the line (on write).  Can be called even if cache line is invalid
    // and will have no effect.
    void setDirtyWord(uint32_t addr);
    void setDirtyLine(uint32_t addr);
    // Return true if the word is dirty.  The addr is word-aligned.
    bool IsDirtyWord(uint32_t addr);
    // Return true if any of the words are dirty.  The addr is cacheline aligned.
    bool IsDirtyLine(uint32_t addr);
    // Clears the dirty bit for line.  Writeback handled separately
    void clearDirtyWord(uint32_t addr);
    void clearDirtyLine(uint32_t addr);
    // Return true if the word is valid in the cache.
    bool IsValidWord(uint32_t addr);
    // Return true if any of the words are valid in the cache.
    bool IsValidLine(uint32_t addr);
    // Invalidate all entries in cache
    void invalidate_all();
    // Invalidate a single line
    void invalidate_line(uint32_t addr);
    // Invalidate a single word
    void invalidate_word(uint32_t addr);

    // Wait on a fill for a fixed or variable latency
    void pend( const CacheAccess_t ca_in, int latency, int ccache_pending_index, 
      bool is_eviction, bool vlat);

    // Make line of addr valid in cache.
    bool Fill(uint32_t addr);
    // Make line of addr valid in the cache and set the prefetch bit on the line
    // if necessary.
    bool Fill(uint32_t addr, bool was_prefetch);
    // Evict a cache line that shares the same way as addr (BUT NOT ADDR)
    // Returns the newly available way
    int evict(uint32_t addr, bool &stall);
    // This was pure virtual, but the L1's do not need it so I
    //  changed it.
    // It was just dead code in G$ as well.  Removed.
    virtual void
      Schedule(int size, MissHandlingEntry<rigel::cache::LINESIZE> *MSHR) {}
    // PendingMiss interface.  I added this so that we can control access to the
    // list of MSHRs for the cache.  Right now they are all over the place.  I
    // would like to make the pendingMiss array private ASAP.  I would also like
    // to move this into a separate class/interface to tidy up CacheBase.
    // Return valid status of a miss register.
    bool PM_get_valid(int i) const { return validBits.test(i); }
    // Return the address of the pending miss.
    std::set<uint32_t> &PM_get_addrs(int i) { return pendingMiss[i].get_addrs(); }
    // Return the ICMsg type of the miss.
    icmsg_type_t PM_get_icmsg_type(int i) const { return pendingMiss[i].GetICMsgType(); }
    // Callbacks used to set the delay from outside of the cache.
    // Used by memory controller/cluster controller to set delay in the future
    // for GC/CC scheduling.
    bool PM_get_sched(int i) { return pendingMiss[i].IsScheduled(); }
    // Return true if the message has been scheduled/acked at the global/cluster
    // cache.
    bool PM_get_acked(int i) { return pendingMiss[i].IsRequestAcked(); }
    // Return the timing waiting since the last WDT reset
    int PM_get_WDTwait(int i) { return(rigel::CURR_CYCLE-pendingMiss[i].watchdog_last_set_time); }
    // Return true if the MISS is ready to be filled into the cache.
    bool PM_get_ready(int i) { return (pendingMiss[i].IsDone()); }
    // Return the instruction associated with the miss.  May return NULL.
    InstrLegacy *PM_get_instr(int i) { return pendingMiss[i].instr; }
    // Printout status of the MSHR to the console.  For debug purposes.
    void PM_dump(int i) const { pendingMiss[i].dump(); }
    // Return a reference to the MSHR for the index.
    MissHandlingEntry<linesize> &PM_get_mshr(int idx) { return pendingMiss[idx]; }
    // Clearning an MSHR is a two-phase process.  First:Try to clear() the MSHR.
    // May be undone later with unclear().
    void PM_clear(int i) { pendingMiss[i].clear(); }
    void PM_unclear(int i) { pendingMiss[i].unclear(); }
    // Return the index of an unused MSHR in idx.  Returns true on success.
    bool PM_find_unused_mshr(int & idx);
    //Get the fill address for MSHR[i]
    uint32_t PM_get_fill_addr(int i) const { return pendingMiss[i].get_fill_addr(); }
    //Are one or more lines waiting to be filled into the cache?
    bool PM_has_ready_line(int i) const { return pendingMiss[i].has_ready_line(); }
    //Tell the MSHR that a fill has occurred for the specified address
    void PM_notify_fill(int i, uint32_t addr) { pendingMiss[i].notify_fill(addr); }
    void PM_set_line_ready(int i, uint32_t addr, uint64_t ready_cycle)
    {
      pendingMiss[i].set_line_ready(addr, ready_cycle);
    }
    // Insert a new request into the pending misses pool. Returns a reference to the MSHR that
    // it generates.
    MissHandlingEntry<linesize> &
    // PM_insert_new_request(int idx, uint32_t addr, icmsg_type_t icmsg_type,
    //   int core_id, int ccache_pending_idx, bool is_eviction, InstrLegacy *instr,
    //   bool variable_latency, net_prio_t net_priority);
    PM_insert_new_request( CacheAccess_t ca_in,
        int idx,  int ccache_pending_idx, bool is_eviction, bool variable_latency);

    // Returns true if there are no requests pending.
    // TODO this would be faster if the free list were a used list (reverse the sense)
    bool PM_none_pending() const { return validBits.allClear(); }
    // Dump the contents of all of the MSHRs in the cache.
    void dump() const;
    // Decrement the WDT for ack's.  When it hits zero, return true, else return false.
    bool PM_DEBUG_inc_acked_WDT(int idx)
      { if (pendingMiss[idx].ack_WDT-- < 0) { return true; } return false; }
    // Decrement the WDT for sched's.  When it hits zero, return true, else return false.
    bool PM_DEBUG_inc_sched_WDT(int idx)
      { if (pendingMiss[idx].sched_WDT-- < 0) { return true; } return false; }

  public: /* DATA */
    MissHandlingEntry<linesize> pendingMiss[MAX_OUTSTANDING_MISSES];

    // All word bits for a cache line turned on.
    const uint32_t CACHE_ALL_WORD_MASK;
    uint32_t SET_SHIFT;
    uint32_t SET_MASK;
    int MSHR_COUNT;
    int numWays;
    int numSets;
    // Storage for tag data
    CacheTag TagArray[sets][ways];

  protected:
  // Track which MSHRs are free.
    DynamicBitset validBits;
    // indicate current miss buffer to begin scan from, mimic round-robin behavior of mshr's
    // not sure if this is redundant or conflicts with the PM_ interface, it was used in the
    // rigel-lt tree so brought over here for use in ICache MT fetch issue
    uint32_t miss_buffer_head;
    
  private: /* DATA */

  // We want to allow the cache model and global network to touch the privates of the caches.
  friend class CacheModel;
};

/********************** BEGIN CacheBase implementation ************************/
////////////////////////////////////////////////////////////////////////////////
// CacheBase Constructor
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
CacheBase () :
  CACHE_ALL_WORD_MASK((1UL << (rigel::cache::LINESIZE/4)) - 1),
  SET_MASK(sets - 1),
  MSHR_COUNT(MAX_OUTSTANDING_MISSES),
  numWays(ways),
  numSets(sets),
  validBits(MAX_OUTSTANDING_MISSES),
  miss_buffer_head(0)
{
  SET_SHIFT = rigel_log2(linesize);
  // Clear all of the pending misses.
  for (int i = 0; i < MAX_OUTSTANDING_MISSES; i++) {
    pendingMiss[i].init(i, &validBits); //Pass in pointer to valid bitset
#ifdef DEBUG_CACHES
    cerr << "CacheBase ctor mshr init ID " << i << std::endl;
#endif
    pendingMiss[i].clear(); //Must happen after init(), else segfault
  }
}

////////////////////////////////////////////////////////////////////////////////
// CacheBase::touch()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline void
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  touch(uint32_t addr)
{
  int set = get_set(addr);
  int way = get_way_line(addr, set);
  if (way != -1) { TagArray[set][way].touch(); }
}

////////////////////////////////////////////////////////////////////////////////
// ClearHWPrefetch()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline void
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  ClearHWPrefetch(uint32_t addr)
{
  int set = get_set(addr);
  int way = get_way_line(addr, set);

  if (way != -1) { TagArray[set][way].clear_hwprefetch(); }
}

////////////////////////////////////////////////////////////////////////////////
// ClearBulkPrefetch()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline void
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  ClearBulkPrefetch(uint32_t addr)
{
  int set = get_set(addr);
  int way = get_way_line(addr, set);

  if (way != -1) { TagArray[set][way].clear_bulkprefetch(); }
}

////////////////////////////////////////////////////////////////////////////////
// IsHWPrefetch()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline bool
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  IsHWPrefetch(uint32_t addr)
{
  int set = get_set(addr);
  int way = get_way_line(addr, set);

  if (way != -1) { return TagArray[set][way].is_hwprefetch(); }
  else           { return false; }
}

////////////////////////////////////////////////////////////////////////////////
// IsBulkPrefetch()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline bool
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  IsBulkPrefetch(uint32_t addr)
{
  int set = get_set(addr);
  int way = get_way_line(addr, set);

  if (way != -1) { return TagArray[set][way].is_bulkprefetch(); }
  else           { return false; }
}

////////////////////////////////////////////////////////////////////////////////
// getWordBitsForLine()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline uint32_t
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  getWordBitsForLine(uint32_t addr)
{
  uint32_t offset = ((addr & (rigel::cache::LINESIZE-1))) >> 2;
  uint32_t word_bit = 1UL << offset;

  return word_bit;
}


////////////////////////////////////////////////////////////////////////////////
// setValidWord()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline void
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  setValidWord(uint32_t addr)
{
  int set = get_set(addr);
  int way = get_way_line(addr, set);
  uint32_t valid_bits = getWordBitsForLine(addr);

  if (way != -1) { TagArray[set][way].make_valid(addr, valid_bits); }
  else {
    DEBUG_HEADER();
    fprintf(stderr, "Attempting to validate word in an uncached line!\n");
    assert(0);
  }
}


////////////////////////////////////////////////////////////////////////////////
// getValidMask()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline uint32_t
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  getValidMask(uint32_t addr)
{
  int set = get_set(addr);
  int way = get_way_line(addr, set);

  if (way != -1) { return TagArray[set][way].get_valid_mask(); }
  else {  return 0; }
}


////////////////////////////////////////////////////////////////////////////////
// setDirtyWord()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline void
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  setDirtyWord(uint32_t addr)
{
  int set = get_set(addr);
  int way = get_way_word(addr, set);
  uint32_t dirty_bit = getWordBitsForLine(addr);

  if (way != -1) { TagArray[set][way].set_dirty(addr, dirty_bit);}
}


////////////////////////////////////////////////////////////////////////////////
// setDirtyLine()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline void
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  setDirtyLine(uint32_t addr)
{
  int set = get_set(addr);
  int way = get_way_line(addr, set);

  if (way != -1) { TagArray[set][way].set_dirty(addr, CACHE_ALL_WORD_MASK); }
}

////////////////////////////////////////////////////////////////////////////////
// clearDirtyWord()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline void
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  clearDirtyWord(uint32_t addr)
{
  int set = get_set(addr);
  int way = get_way_word(addr, set);
  uint32_t clean_bit = getWordBitsForLine(addr);

  if (way != -1) { TagArray[set][way].clear_dirty(addr, clean_bit); }
}


////////////////////////////////////////////////////////////////////////////////
// clearDirtyLine()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline void
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  clearDirtyLine(uint32_t addr)
{
  int set = get_set(addr);
  int way = get_way_line(addr, set);
  if (way != -1) { TagArray[set][way].clear_dirty(addr, CACHE_ALL_WORD_MASK); }
}

////////////////////////////////////////////////////////////////////////////////
// invalidate_all();
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline void
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  invalidate_all()
{
  for (int s = 0; s < sets; s++) {
    for (int w = 0; w < ways; w++) {
      TagArray[s][w].invalidate();
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
// invalidate_line()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline void
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
invalidate_line(uint32_t addr)
{
  int set = get_set(addr);
  int way = get_way_line(addr, set);
  // Not in cache.
  if (way < 0) return;

  TagArray[set][way].invalidate(addr, CACHE_ALL_WORD_MASK);
}

////////////////////////////////////////////////////////////////////////////////
// invalidate_word()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline void
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
invalidate_word(uint32_t addr)
{
  int set = get_set(addr);
  int way = get_way_line(addr, set);
  // Not in cache.
  if (way < 0) return;
  int word_num = (addr % linesize) / 4;
  uint32_t invalidate_mask = 1U << word_num;
  TagArray[set][way].invalidate(addr, invalidate_mask);
}

////////////////////////////////////////////////////////////////////////////////
// get_way_word()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline int
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  get_way_word(uint32_t addr) const
{
  int set = get_set(addr);

  for (int i = 0; i < ways; i++) {
    uint32_t word_mask = getWordBitsForLine(addr);
    if (TagArray[set][i].hit(addr, word_mask)) { return i; }
  }

  return -1;
};

////////////////////////////////////////////////////////////////////////////////
// get_way_word()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline int
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  get_way_word(uint32_t addr, int set) const
{
  for (int i = 0; i < ways; i++) {
    uint32_t word_mask = getWordBitsForLine(addr);
    if (TagArray[set][i].hit(addr, word_mask)) { return i; }
  }

  return -1;
};

////////////////////////////////////////////////////////////////////////////////
// get_way_line()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline int
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  get_way_line(uint32_t addr) const
{
  int set = get_set(addr);
  return get_way_line(addr, set);
};

////////////////////////////////////////////////////////////////////////////////
// get_way_line()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline int
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  get_way_line(uint32_t addr, int set) const
{
  for (int i = 0; i < ways; i++) {
    if (TagArray[set][i].tag_check(addr)) { return i; }
  }
  return -1;
};

//FIXME Comment me, especially regarding
//race condition with evicted lines.
CACHE_TEMPLATE
inline bool
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  is_being_evicted(uint32_t addr) const
{
  //uint32_t old_addr = addr;
  addr &= rigel::cache::LINE_MASK;
  int set = get_set(addr);
  for (int i = 0; i < ways; i++) {
    if (TagArray[set][i].locked() && (TagArray[set][i].victim_addr() == addr)) {
      //fprintf(stderr, "0x%08"PRIX64" : 0x%08"PRIX32" (0x%08"PRIX32") IS being evicted\n", rigel::CURR_CYCLE, old_addr, addr);
      return true;
    }
  }
  //if((addr & 0xFFC0) == 0xBE40) {
  //  fprintf(stderr, "0x%08"PRIX64" : 0x%08"PRIX32" (0x%08"PRIX32") IS NOT being evicted\n", rigel::CURR_CYCLE, old_addr, addr);
  //}
  return false;
}

////////////////////////////////////////////////////////////////////////////////
// pend()
////////////////////////////////////////////////////////////////////////////////
// This queues a pending request onto the Nth level of the cache to the N+1th
// level of the cache.  It can be variable latency or not.  If it is variable
// latency, the PerCycle() method will keep trying to schedule the request with
// the next level of the cache at which point the SetSchedule() call will set a
// fixed latency for the request.  The fixed latency is what ever the latency is
// between the two levels of the cache ones the value is available in the next
// level of the cache.  For fixed latency requests, they are set scheduled
// immediately and PerCycle clocks down the number of delay cycles until the
// request can be serviced.
CACHE_TEMPLATE
inline void
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES,  WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  pend( const CacheAccess_t ca_in, int latency, int ccache_pending_index, bool is_eviction, bool vlat)
{
  if (ca_in.get_icmsg_type() == IC_MSG_NULL) {
    DEBUG_HEADER();
    fprintf(stderr, "Found IC_MSG_NULL being pended! addr: %08x core: %d\n",
      ca_in.get_addr(), ca_in.get_core_id() );
    assert(0);
  }
#ifdef DEBUG_CACHES
  cerr << "CacheBase pend() start\n";
#endif

  CacheAccess_t ca_out = ca_in; // same params as input
  // override the address
  ca_out.set_addr( ca_in.get_addr() & rigel::cache::LINE_MASK );

  // TODO: just pass ca_out to some init/setting function...
  int i = validBits.findFirstClear();
  if(i == -1)
    assert(0 && "Could not find MSHR to allocate");

  pendingMiss[i].set(ca_out.get_addr(), latency, vlat,
    ca_out.get_icmsg_type(), ca_out.get_core_id(), i,
    ca_out.get_tid());

  pendingMiss[i].instr = ca_out.get_instr();
  return;
}

////////////////////////////////////////////////////////////////////////////////
// IsValidWord()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline bool
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES,  WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
IsValidWord(uint32_t addr)
{
  int set = get_set(addr);
  int way = get_way_word(addr, set);

  if (way == -1) { return false; }
  assert(way >= 0 && way < numWays && "Invalid way number returned");

  return true;
}

////////////////////////////////////////////////////////////////////////////////
// get_accessed_bit()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline bool
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES,  WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
get_accessed_bit(uint32_t addr) const
{
  int set = get_set(addr);
  int way = get_way_word(addr, set);

  if (way == -1) { return false; }
  assert(way >= 0 && way < numWays && "Invalid way number returned");

  return TagArray[set][way].get_accessed_bit();
}

////////////////////////////////////////////////////////////////////////////////
// set_accessed_bit_read()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline void
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES,  WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
set_accessed_bit_read(uint32_t addr)
{
  int set = get_set(addr);
  int way = get_way_word(addr, set);

  if (way == -1) { return; }
  assert(way >= 0 && way < numWays && "Invalid way number returned");

  return TagArray[set][way].set_accessed_bit_read();
}

////////////////////////////////////////////////////////////////////////////////
// set_accessed_bit_write()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline void
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES,  WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
set_accessed_bit_write(uint32_t addr)
{
  int set = get_set(addr);
  int way = get_way_word(addr, set);

  if (way == -1) { return; }
  assert(way >= 0 && way < numWays && "Invalid way number returned");

  return TagArray[set][way].set_accessed_bit_write();
}

////////////////////////////////////////////////////////////////////////////////
// IsValidLine()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline bool
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES,  WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
IsValidLine(uint32_t addr)
{
  int set = get_set(addr);
  int way = get_way_line(addr, set);

  if (way == -1) { return false; }
  assert(way >= 0 && way < numWays && "Invalid way number returned");

  // Touch on every valid IsValid reply.  Accumulates count of read/writes to
  // location in the cache.
  TagArray[set][way].touch();

  return true;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <int ways, int sets, int linesize, int max_osm, int wb_policy, int evict_buf_sz>
inline bool
CacheBase<ways, sets, linesize, max_osm, wb_policy, evict_buf_sz>::
PM_find_unused_mshr(int & idx)
{
  idx = validBits.findFirstClear();
  if(idx == -1)
    return false;
  else
    return true;
}

////////////////////////////////////////////////////////////////////////////////
// PM_insert_new_request()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline MissHandlingEntry<linesize> &
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES,  WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
PM_insert_new_request(
  CacheAccess_t ca_in,
  int idx,
  int ccache_pending_idx,
  bool is_eviction,
  bool variable_latency
) {
  // Set up the MSHR
  pendingMiss[idx].set(
    ca_in.get_addrs(),
    -11,
    variable_latency,
    ca_in.get_icmsg_type(),
    ca_in.get_core_id(),
    ccache_pending_idx,
    ca_in.get_tid()
  );

  // Track the instruction that generated the miss.  May be NULL.
  pendingMiss[idx].instr = ca_in.get_instr();

  // Reset the WDTs
  pendingMiss[idx].sched_WDT = rigel::cache::CACHEBASE_SCHED_WDT;
  pendingMiss[idx].ack_WDT   = rigel::cache::CACHEBASE_ACK_WDT;

  // Return the freshly minted MSHR
  return pendingMiss[idx];
}

////////////////////////////////////////////////////////////////////////////////
// evict()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
int
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
evict(uint32_t addr, bool &stall)
{

  // XXX NOTE: Comments for this are in L2Cache::evict() since they are so
  // similar.  Any differences should be noted here.
  int victim;
  bool dirty_victim = false;
  int set = get_set(addr);
  uint32_t victim_addr;
  stall = true;

  for (int i = 0; i < numWays; i++) {
    if (TagArray[set][i].locked()) {
      victim_addr = TagArray[set][i].victim_addr();
      victim = i;
      dirty_victim = true;
      #ifdef DEBUG_EVICT
      cerr << "DEBUG_EVICT (L1): [locked] @ 0x" << HEX_COUT << rigel::CURR_CYCLE;
      cerr << " VADDR: 0x" << HEX_COUT << victim_addr;
      cerr << " ADDR: 0x" << HEX_COUT << addr;
      cerr << " SET: " << dec << set;
      cerr << " WAY: " << dec << i;
      cerr << endl;
      #endif
      goto try_pend;
    }
  }

  // Always evict an invalid line first
  for (int i = 0; i < numWays; i++) {
    if (!TagArray[set][i].valid()) { victim = i; goto done; }
  }

  // Random enough for me
  victim = (rigel::CURR_CYCLE) % numWays;
  // FIXME FIXME
  //assert(0 && "what the heck? we are randomly evicting? OMG u gotta b kidding d00d!");

  // Need to make sure we pick one that is not being filled currently otherwise
  // deadlock *will* happen, I know...
  {
    int victim_start = victim;
    while (TagArray[set][victim].locked()) {
      victim = (victim + 1) % numWays;
      assert(victim != victim_start && "All entries are locked!");
    }
  }

  // TODO Handle Writeback if needed
  victim_addr = TagArray[set][victim].get_tag_addr();
  dirty_victim = TagArray[set][victim].dirty(victim_addr, CACHE_ALL_WORD_MASK);

  #ifdef DEBUG_EVICT
  cerr << "DEBUG_EVICT (L1): VICTIM @ 0x" << HEX_COUT << rigel::CURR_CYCLE;
  cerr << " VADDR: 0x" << HEX_COUT << victim_addr;
  cerr << " ADDR: 0x" << HEX_COUT << addr;
  cerr << " SET: " << dec << set;
  cerr << " WAY: " << dec << victim;
  cerr << endl;
  #endif

  // Invalidate the victim for the time being so that a subsequent access to the
  // line will be queued but this may be wrong, I dunno...
  TagArray[set][victim].invalidate();

try_pend:
  // If the address is already being written back or it is not dirty, then we can
  // skip trying to grab an MSHR and pending it.
  if ((IsPending(victim_addr) == NULL) && dirty_victim) {
    if (mshr_full()) {
      #ifdef DEBUG_EVICT
      cerr << "DEBUG_EVICT (L1): No MSHR available (stall)";
      cerr << " @ 0x" << HEX_COUT << rigel::CURR_CYCLE;
      cerr << " VADDR: 0x" << HEX_COUT << victim_addr;
      cerr << " ADDR: 0x" << HEX_COUT << addr;
      cerr << " SET: " << dec << set;
      cerr << " WAY: " << dec << victim;
      cerr << endl;
      #endif
      // Allocate the slot, but we have to wait until the upper level of the cache
      // takes it before we can allow the fill to proceed.
      stall = true;
      TagArray[set][victim].set_victim_addr(victim_addr);
      TagArray[set][victim].lock(addr);

      return 0;
    }

    #ifdef DEBUG_EVICT
    {
    cerr << "DEBUG_EVICT (L1): pend(victim_addr)";
    cerr << " @ 0x" << HEX_COUT << rigel::CURR_CYCLE;
    cerr << " VADDR: 0x" << HEX_COUT << victim_addr;
    cerr << " ADDR: 0x" << HEX_COUT << addr;
    cerr << endl;
    }
    #endif
    // If line is now not dirty, nothing to evict.
    if (!IsDirtyLine(victim_addr)) { goto done; }

    CacheAccess_t ca(
      victim_addr,            // address
      rigel::POISON_COREID, // core number (faked)
      rigel::POISON_TID,    // thread id
      IC_MSG_EVICT_REQ,       // interconnect message type
      rigel::NullInstr      // no instruction correlated to this access
    );

    // Writebacks are given a fake core id.
    pend(ca,
      rigel::cache::L1D_ACCESS_LATENCY,
      rigel::CORES_PER_CLUSTER, false, false);
    // Line is no longer dirty but it is locked until fill happens from higher
    // level of the cache
    TagArray[set][victim].clear_dirty(victim_addr, CACHE_ALL_WORD_MASK);
  }

done:
    #ifdef DEBUG_EVICT
      cerr << "DEBUG_EVICT (L1): Evict Complete (no stall)";
      cerr << " @ 0x" << HEX_COUT << rigel::CURR_CYCLE;
      cerr << " VADDR: 0x" << HEX_COUT << victim_addr;
      cerr << " ADDR: 0x" << HEX_COUT << addr;
      cerr << endl;
    #endif

  stall = false;
  return victim;
}

////////////////////////////////////////////////////////////////////////////////
// IsDirtyLine()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline bool
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::IsDirtyLine(uint32_t addr)
{
  int set = get_set(addr);
  int way = get_way_line(addr, set);

  if (way == -1) { return false; }
  assert(way >= 0 && way < numWays && "Invalid way number returned");

  bool dirty = TagArray[set][way].dirty(addr, CACHE_ALL_WORD_MASK);

  return dirty;
}

////////////////////////////////////////////////////////////////////////////////
// IsDirtyWord()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline bool
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::IsDirtyWord(uint32_t addr)
{
  int set = get_set(addr);
  int way = get_way_word(addr, set);

  if (way == -1) { return false; }
  assert(way >= 0 && way < numWays && "Invalid way number returned");

  uint32_t dirty_mask = getWordBitsForLine(addr);
  bool dirty = TagArray[set][way].dirty(addr, dirty_mask);

  return dirty;
}

////////////////////////////////////////////////////////////////////////////////
// mshr_full()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline bool
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
mshr_full(bool is_eviction)
{
  if (is_eviction) {
    return (validBits.allSet());
  } else {
    return (validBits.getNumSetBits() >= (MAX_OUTSTANDING_MISSES - CACHE_EVICTION_BUFFER_SIZE));
  }
}

////////////////////////////////////////////////////////////////////////////////
// dump()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline void
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
dump() const
{
  fprintf(stderr, "CACHE MODEL DUMP: sets: %4d ways: %4d linesize %3d MAX outstanding misses: %3d "
                  "eviction count: %2d Valid MSHRs: %3zu Invalid MSHRs: %3zu ",
                  sets, ways, linesize, MAX_OUTSTANDING_MISSES, CACHE_EVICTION_BUFFER_SIZE, validBits.getNumSetBits(), validBits.getNumClearBits());
	std::cerr << "Valid bits: "; validBits.print(stderr); std::cerr << "\n";
  //TODO make faster
  for (int i = 0; i < MAX_OUTSTANDING_MISSES; i++) {
    if (PM_get_valid(i)) {
      PM_dump(i); std::cerr << "\n";
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
// set_coherence_state()
////////////////////////////////////////////////////////////////////////////////
CACHE_TEMPLATE
inline void
CacheBase<ways, sets, linesize, MAX_OUTSTANDING_MISSES, WB_POLICY, CACHE_EVICTION_BUFFER_SIZE>::
  set_coherence_state(uint32_t addr, coherence_state_t state)
{
  int set = get_set(addr);
  int way = get_way_line(addr, set);

  if (way == -1) { return; }
  assert(way >= 0 && way < ways && "Invalid way number returned");

  TagArray[set][way].set_coherence_state(state);
}
#endif //#ifndef __CACHE_BASE_H__




