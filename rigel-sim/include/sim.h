#ifndef __SIM_H__
#define __SIM_H__

////////////////////////////////////////////////////////////////////////////////
// sim.h
////////////////////////////////////////////////////////////////////////////////
//
// Main configuration file for RigelSim.  Contains all the namespace
// declarations and includes typedefs and #defines from define.h and user.confg,
// respectively.
//
// PLEASE FORGIVE US FOR THIS FILE!!!
//
////////////////////////////////////////////////////////////////////////////////

#include "config.h"

// FIXME: move to a debug print file
#define DPRINTOLD(...) fprintf ( stdout, __VA_ARGS__ )
#define DPRINT(cond,...) { if (cond) {fprintf ( stdout, __VA_ARGS__ );} }
//#define DRIGEL(blah) blah
#define DRIGEL(blah)
//#define DPRINT

// XXX: user.config must be hand made for each user.  Check user.config.example
#include "../user.config"

//#define DEBUG_MT
//#define DEBUG_ARB
//#define DEBUG_CACHES

#ifndef __USER_CONFIG__
#error You must copy user.config.default to user.config before building
#endif

//
// System specific includes
//
 #ifdef _WIN32
 	#define snprintf _snprintf
 	#define __func__ __FUNCTION__
 	#define random rand
 	#include <io.h>
 	#include <windows.h>
 #else
// 	#include <sys/time.h>
// 	#include <unistd.h>
#endif

#include <iomanip>
#include <list>
#include <vector>
#include <map>
#include <string>
#include <stdint.h>
#include <limits>
//execinfo.h is used for backtraces, and is not available on all platforms
//FIXME do a more robust check in configure.ac
#ifdef __linux__
#include <execinfo.h>
#endif

// // Common #define functions and variables.
 #include "define.h"
// ISA information generated by libisa.
#include "autogen/autogen_isa_sim.h"
// Include files from libelf and binutils.
#ifdef ENABLE_GPLV3
extern "C" {
#include "dis-asm.h"
#include "bfd.h"
}
#endif

// Include protobuf typedefs, helpers
#include <google/protobuf/stubs/common.h>

//
// GNU binutils defines inline to nothing for Visual C++, obviously we don't
// want that, so just undefine inline
//
#ifdef _MSC_VER
	#undef inline
#endif // _MSC_VER

// Bring in constants shared by the libraries and the simulator.
#include "rigellib.h"

namespace rigel {
  extern GlobalBackingStoreType *GLOBAL_BACKING_STORE_PTR;
}

namespace rigel {
  namespace components {
  }
}

// FIXME remove me temporary
class ClusterBase;
class ClusterLegacy;
class ClusterSimple;
//typedef ClusterLegacy ClusterType;
//typedef ClusterSimple ClusterType;

// Memory Model Classes
class MemoryModelSimple;
class MemoryModelBlocked;
class MemoryTimingDRAM;

// Arbiter Classes
class BusArbiter;
class XBarArbiter;
class TaskSystemBaseline;

// Needed by namespace verif
extern class TaskSystemBaseline *GlobalTaskQueue;
struct ProfileStat;
class GlobalCache;
// Used for profiling and for memory controller.
extern class GlobalCache ** GLOBAL_CACHE_PTR;
// Global register file zero tracker
extern class ZeroTracker * GLOBAL_ZERO_TRACKER_PTR;

class InstrLegacy;
namespace rigel {
  extern InstrLegacy * NullInstr; // InstrLegacy* is an InstrSlot
}

namespace rigel {
  const float CLK_FREQ = 1.2; //Core clock frequency, in GHz
  //NOTE: Cores, C$, Interconnect, G$ run at this frequency.  DRAM controller and DRAM channel
  //model run at rigel::DRAM::CLK_FREQ (see note in dram.h)
  extern std::string RIGELSIM_BINARY_PATH;
  extern std::string BENCHMARK_BINARY_PATH;
  extern std::vector<std::string> SIM_TAGS;
  extern time_t SIM_START_TIME;
  extern time_t SIM_END_TIME;
  extern std::string COUCHDB_HOSTNAME;
  extern int COUCHDB_PORT;
  extern std::string COUCHDB_DBNAME;
  //Once STDIN_AS_std::string reaches this length, we don't want it in the DB, so poison it.
  const long STDIN_AS_STRING_MAXLENGTH=1024;
  extern std::ostringstream STDIN_AS_STRING;
  extern bool STDIN_AS_STRING_SHORT_ENOUGH; //starts as true, set to false if MAXSIZE is exceeded.
  extern std::vector<std::string> TARGET_ARGS;
  // Set to true if you want to dump the system state on simulator exit (success only).
  const bool PRINT_TERMINAL_SYSTEM_STATE = false;
  // Set to print out a warning when you read a memory word that has not been written to.
  // We would normally like to do this always (the backing store knows this information
  // already so it doesn't cost anything), but several benchmarks (dmm, sobel, mri, etc.)
  // do this on purpose because their computation is not data-dependent and they don't want
  // to simulate the calculation of dummy values or slurp in a file.
  // TODO We should fix these benchmarks to do the right thing so we can turn on Valgrind-like
  // memory checking.
  const bool WARN_ON_UNINITIALIZED_MEMORY_ACCESSES = false;

  // Coherence directory sets/ways per G$ bank.
  extern int COHERENCE_DIR_SETS;
  extern int COHERENCE_DIR_WAYS;
  // Sparse directory replacement policy
  enum DirectoryReplacementPolicy
  {
    dir_rep_lru, //Least recently touched
    dir_rep_lfu, //Least frequently touched since allocated
    dir_rep_lu,  //Least touched since allocated
    dir_rep_lra, //Least recently allocated
    dir_rep_ls   //Least shared (lowest (# sharers / cycles allocated))
  };
  // Set at runtime (defined in cmdline_parse.cpp)
  extern DirectoryReplacementPolicy DIRECTORY_REPLACEMENT_POLICY;
  // Set at run time and checked every cycle.  (defined in sim.cpp)
  extern uint64_t CYC_COUNT_MAX;
  // Incremented every cycle.  (defined in: sim.cpp)
  extern uint64_t CURR_CYCLE;
  // Place holder for memory output filename. (defined in sim.cpp)
  extern char MEM_DUMP_FILE[1024];
  // Path set for dump files. (defined in util.cpp)
  extern std::string DUMPFILE_PATH;
  // Cycles without retiring an instruction to wait before barfing
  const int DEADLOCK_WATCHDOG = 10000;
  // Make the simulation output time readable in days/hours/minutes/seconds.
  // (used by profile.cpp);
  const bool HUMAN_READABLE_TIME = true;
  // Used in on-the-fly memory allocator DRAMModel
  // XXX BEWARE of constants > 32 bits long! They are busted! XXX
  const uint64_t MEM_SIZE = (uint64_t)((uint64_t)4*1024*1024*1024); /* 4 GiB */
  // Used for simple memory model to reduce allocated space
  const uint64_t SIMPLE_MEM_SIZE = (uint64_t)(64*1024*1024);  /* 64 //16 MiB*/
  // Used for on-the-fly blocked memory model (used in memory_model.[cpp|h]
  const uint32_t BLOCKED_MEM_SIZE_LOG2 = 32 ; // 4GB
  const uint32_t BLOCKED_MEM_BLOCK_SIZE = (16*1024);     // 16KB
  const uint32_t BLOCKED_MEM_NUM_BLOCKS =
    (uint32_t)( (((uint64_t)0x1UL)<<BLOCKED_MEM_SIZE_LOG2) / (uint64_t)BLOCKED_MEM_BLOCK_SIZE);
  const uint32_t MEM_WORD_SIZE = sizeof(uint32_t);
  const uint32_t MEM_WORD_COUNT = (uint32_t)(MEM_SIZE / MEM_WORD_SIZE);
  const uint64_t TOP_OF_MEM = MEM_SIZE;
  const uint32_t INVALID_REG = 0xDEAD;
  // Maximum number of SimTimers to allow in simulation. Arbitrary.
  static const int NUM_TIMERS = 0x1000;
  // This get set to the maximum address occupied by a code word.  For
  // debugging/sanity since we have no SMC.  Set in util: LoadELF
  extern uint32_t CODEPAGE_HIGHWATER_MARK;
  extern uint32_t CODEPAGE_LIBPAR_BEGIN;
  extern uint32_t CODEPAGE_LIBPAR_END;
  extern uint32_t LOCKS_REGION_BEGIN;
  extern uint32_t LOCKS_REGION_END;

	extern std::vector<uint32_t> ENTRY_POINTS; //Array of starting PCs for each thread.

  // Allow disabling of profiling.
  const bool PROFILER_ACTIVE = true;
  // Debugging mechanism.  Set when simulator decodes a breakpoint and stop
  // simulation and jump into interactive mode.
  extern bool BREAKPOINT_PENDING;
  // If true, log all memory references. (defined in util.cpp, set by sim.cpp)
  // Cluster cache level
  extern bool GENERATE_CCTRACE;
  // DRAM level
  extern bool GENERATE_DRAMTRACE;
  // Coherence traffic
  extern bool GENERATE_COHERENCETRACE;
  // HW Coherence Directory eviction logging
  extern bool GENERATE_DIREVICTTRACE;
  // Dump stats on SIGINT catch?
  // Default to false (no) to avoid accidentally using partial results,
  // but can be turned on when partial runs are desired.
  extern bool SIGINT_STATS;
  // Turn cores off when they are waiting on a C$ MSHR?
  // it will mess up statistics slightly, but may make things faster if there
  // is a lot of stalling going on.
  extern bool SLEEPY_CORES;
  extern bool START_AWAKE_NOT_ASLEEP;
	extern bool SINGLE_THREADED_MODE; //Only thread 0 starts, the rest are halted.
  // Track and report the number of zero bits, niblets, nibbles, bytes, half-words, words, etc.
  // written into our register files (TODO: and caches).
  // Could be useful data to motivate a scheme along the lines of "Dynamic Zero Compression for Cache Energy Reduction"
  // by L Villa (K. Asanovic's student).
  extern bool TRACK_BIT_PATTERNS;
  // Sparse directory replacement policy
  enum PipelineBypassPaths
  {
    pipeline_bypass_full, //Default, full bypass
    pipeline_bypass_none //No bypass paths
    //TODO add intermediate amounts of bypassing
  };
  // Set at runtime (defined in cmdline_parse.cpp)
  extern PipelineBypassPaths PIPELINE_BYPASS_PATHS;
  
  // The number of pipelines supported.  This is the maximum issue width.  The
  // actual issue width is depdendent on FU availability.
  const int ISSUE_WIDTH = 2;
  // Number of registers in the general-purpose register file.
  const unsigned int NUM_REGS = 32;
  // Number of special-purpose registers.
  const unsigned int NUM_SREGS = SPRF_NUM_SREGS;
  // Number of special-purpose registers.
  const int NUM_AREGS = 8;
  // Number of cores in a cluster, nominally eight.
  const int CORES_PER_CLUSTER = __NUM_CORES_PER_CLUSTER;
  // Lives in sim.cpp and is set there as a runtime constant.
  extern int CORES_TOTAL;
  // Maximum number of memory controllers supported
  const int MAX_MCS = 16;
  //Actual number of G$ banks (declared in cmdline_parse.cpp, set in sim.cpp at runtime)
  extern int NUM_GCACHE_BANKS;
  // Maximum number of clusters supported
  const int MAX_CLUSTERS = __MAX_NUM_CLUSTERS;
  // Nonblocking memory ops in the cores?
  extern bool NONBLOCKING_MEM;
  const bool DEFAULT_NONBLOCKING_MEM = false;
  // These live in sim.cpp and are set in CommandLineArgs()
  extern int NUM_CLUSTERS;
  extern int THREADS_PER_CORE;
  // Number of threads per cluster defined in sim.cpp
  extern int THREADS_PER_CLUSTER;
  extern int L1DS_PER_CORE;
  extern int L1DS_PER_CLUSTER;
  extern int THREADS_TOTAL;
  extern int CLUSTERS_PER_TILE;
  extern int NUM_TILES;
  // Model single-cycle latency for all ALU operations.
  extern bool SINGLE_CYCLE_ALUS;
  // Set the number of BTB entries to support.  BTR == 1.
  extern size_t NUM_BTB_ENTRIES;
  // Enable/Disable Contention Modeling for cache ports.  Defined in util.cpp. On by default.
  extern bool CMDLINE_MODEL_CONTENTION;
  // Enable Global Cache MRU replacement policy.
  extern bool CMDLINE_GLOBAL_CACHE_MRU;
  // Enable/Disable dumping per-bank DRAM stats, in addition to aggregate stats
  extern bool CMDLINE_VERBOSE_DRAM_STATS;
  // for turning on task read/write sharing data collection
  extern bool CMDLINE_DUMP_SHARING_STATS;
  /* Puts contents of local memory into a file at the end of execution */
  const bool DUMP_MEM = CONFIG_DUMP_MEMORY;
  // Pointer to the global memory backing store (FOR DEBUG ONLY!).  Defined in
  // memory_model.cpp.
  extern GlobalBackingStoreType *MEMORY_BACKING_STORE_PTR;

  // Option set at command line to enable/disable timing statistics being
  // printed to STDERR at the conclusion of simulation.
  extern bool PRINT_GLOBAL_TIMING_STATS;
  // Read in a register file state from a file at the start of simulation
  extern bool INIT_REGISTER_FILE;
  // Print the register file to STDERR at exit.
  extern bool DUMP_REGISTER_FILE;
  // Print the register write trace to a file rf.<corenum>.<threadnum>.trace,
  // defined in core.cpp
  extern bool DUMP_REGISTER_TRACE;
  // Dump an ELF code image to file in <addr,data> format
  extern bool DUMP_ELF_IMAGE;
  // Load a checkpoint
  extern bool LOAD_CHECKPOINT;
  // When set, all cores but core zero are halted.  This will put the simulator
  // into a fast-forward-like mode to let core zero boostrap a simulation.
  extern bool SPRF_LOCK_CORES;
  // Set arbiter for L2D (cluster) cache to be a bus.
  //typedef BusArbiter ArbL2Type;
  //typedef BusArbiter ArbL2IType;
  // Output file name for printregs
  const char RIGEL_PRINT_FILENAME[] = "rigelprint.out";
  // File handler for rigel prints.  Defined in util.cpp.
  extern FILE *RIGEL_PRINT_FILEP;
  // Turn on short printing of RigelPrints for faster log parsing.  Defined in
  // util.cpp.  Default: false.
  extern bool CMDLINE_SHORT_RIGELPRINT;
  // Turn off printing RigelPrints all together.  Defined in util.cpp.  Default:
  // false.
  extern bool CMDLINE_SUPPRESS_RIGELPRINT;
  // Turn on interactive mode. Defined in cmdline.cpp.  Default: off.
  extern bool CMDLINE_INTERACTIVE_MODE;
  // Enable cross-core stack smash checking
  extern bool CMDLINE_CHECK_STACK_ACCESSES;
  // Check all of memory for aliasing **SLOW***
  extern bool CMDLINE_ENUMERATE_MEMORY;
  // Turn on coherence for the simulator.  In directory.cpp
  extern bool ENABLE_EXPERIMENTAL_DIRECTORY;
  // for Interactive Mode, which corenum to watch/trace
  extern int INTERACTIVE_CORENUM;
  // Turn on second-level directory.
  extern bool ENABLE_OVERFLOW_DIRECTORY;
  // Area to allow for WayPoint directory entries.
  const uint32_t DIRECTORY_MEMORY_SIZE = (0x1UL << 26);
  // cmdline option for heartbeat interval
  extern int HEARTBEAT_INTERVAL;
  // Command line option for enabling write to write transfers without
  // allocating at the global cache in coherent mode.  By default it should be
  // disabled, but pending simulation results, we may change the default.
  extern bool CMDLINE_ENABLE_GCACHE_NOALLOCATE_WR2WR_TRANSFERS;
  // Enable hybrid coherence scheme.
  extern bool CMDLINE_ENABLE_HYBRID_COHERENCE;
  // Number of allowable broadcasts per directory bank.
  extern int CMDLINE_MAX_BCASTS_PER_DIRECTORY;
  // Addresses in the libraries used for hybrid coherence.  The values are set
  // in crt0.c in /lib/libc/ and are passed into __malloc_init()
  const uint32_t MALLOC_REGION_SIZE =    0x20000000;
  const uint32_t COHERENT_MALLOC_START =  0x00400000;
  const uint32_t COHERENT_MALLOC_END = COHERENT_MALLOC_START+MALLOC_REGION_SIZE;
  const uint32_t INCOHERENT_MALLOC_START = COHERENT_MALLOC_END;
  const uint32_t INCOHERENT_MALLOC_END = INCOHERENT_MALLOC_START+MALLOC_REGION_SIZE;
  // Enable locality tracking
  extern bool ENABLE_LOCALITY_TRACKING;
  // Enable TLB tracking
  extern bool ENABLE_TLB_TRACKING;
  extern bool STDIN_STRING_ENABLE;
  // Pipe a string into stdin
  extern std::string STDIN_STRING;
  extern std::string STDIN_STRING_FILENAME; //Used to store the temporary filename
                                            //so we can remove() it
  // Redirect stdin from file
  extern bool REDIRECT_STDIN;
  // Redirect stdout to file
  extern bool REDIRECT_STDOUT;
  // Redirect stderr to file
  extern bool REDIRECT_STDERR;
  // Enable incoherent malloc when hybridCC is turned on.
  extern bool CMDLINE_ENABLE_INCOHERENT_MALLOC;
  // Make cache accesses for RTM data free.
  extern bool CMDLINE_ENABLE_FREE_LIBPAR;
  extern bool CMDLINE_ENABLE_FREE_LIBPAR_ICACHE;
  // Denotes an invalid thread ID assignment.
  const int32_t POISON_TID    = std::numeric_limits<int>::max();
  // Denotes an invalid core assignment.
  const int32_t POISON_COREID = std::numeric_limits<int>::max();
  // The number of cycles of latency we allow for L2D misses before we stop
  // counting them in the profiler statistics.
  const uint32_t L2D_MISS_LAT_PROFILE_MAX = 50000;
  // Latencies for tile interconnect.
  extern uint32_t TILENET_CC2GNET_LAT_L1;
  extern uint32_t TILENET_GNET2CC_LAT_L1;
  extern uint32_t TILENET_CC2GNET_LAT_L2;
  extern uint32_t TILENET_GNET2CC_LAT_L2;
  // Minimum address for the stack pointer.
  extern uint32_t STACK_MIN_BASEADDR;
  // Idealized DRAM parameters.
  extern bool CMDLINE_ENABLE_IDEALIZED_DRAM;
  extern uint32_t CMDLINE_IDEALIZED_DRAM_LATENCY;
}

namespace rigel {
  namespace core {
    // Pessimistic scoarboard policy that forces the whole pipeline to drain
    // before allowing younger instructions to access the scoreboard.
    const bool FORCE_SB_FLUSH = true;
  }
}

namespace rigel {
  // mem_sched: Constants used for determining DRAM memory scheduling policies.
  namespace mem_sched {
    // Prioritize row hits in the memory controller
    // extern bool MEM_SCHED_ROWHIT; Deprecated 
    // Number of requests to allow to pend for each bank.  More means we can
    // potentially schedule more accesses
    enum DRAMSchedulingPolicy {
      single,
      perbank
    };
    extern DRAMSchedulingPolicy DRAM_SCHEDULING_POLICY;
    //Policy by which we prioritize requests from earlier
    //batches over requests from later batches.
    //This imposes partial orders on requests such that no
    //request can be delayed for more than 1 batch (for fairness).
    //The 'none' policy is the default (since we're throughput-oriented
    //and may not care much about fairness), and the perbank and perchannel
    //policies are similar to policies proposed in the Par-BS paper by
    //Mutlu and Moscibroda, though theirs had a cap on the number of requests
    //in a batch from a given thread to a given bank.  We have too many threads
    //to make this practical.
    enum DRAMBatchingPolicy {
      batch_none,
      batch_perbank,
      batch_perchannel
    };
    //Replacement policy for row cache, if we are using a row cache
    //lru is strict LRU, no matter if the entry is dirty or clean
    //tristage prefers LRU clean lines, then currently open dirty line, then LRU dirty line
    //tristage_b prefers currently open dirty line, then LRU clean line, then LRU dirty line
    //mru is strict MRU
    //TODO: implement some kind of LFU policy
    enum DRAMRowCacheReplacementPolicy {
      rc_replace_lru,
      rc_replace_tristage,
      rc_replace_tristage_b,
      rc_replace_mru,
      rc_replace_lfu
    };
    extern DRAMRowCacheReplacementPolicy ROW_CACHE_REPLACEMENT_POLICY;
    const char ROW_CACHE_REPLACEMENT_POLICY_DEFAULT[] = "tristage";
    extern DRAMBatchingPolicy DRAM_BATCHING_POLICY;
    // Cap on the number of entries per-bank or per-channel before a new batch
    // is formed.  Only valid if DRAM_BATCHING_POLICY is perbank or perchannel.
    extern unsigned int DRAM_BATCHING_CAP; 
    extern int PENDING_PER_BANK;
    // After this number of cycles, we force scheduling of the request.
    const uint32_t MC_FORCE_SCHEDULE_SOFT = 20000;
    const uint32_t MC_FORCE_SCHEDULE_HARD = 40000;
    const uint32_t MC_FORCE_SCHEDULE_WARN = 20000;
    // Checked by memory controller for a pending access. If the access is
    // pending on the memory controller for this long, we reset it and have it
    // try again.
    const uint32_t MC_PENDING_WDT = 80000;
    extern bool MONOLITHIC_SCHEDULER;
  }
}

namespace rigel {
  namespace regs {
    const uint32_t LINK_REG = 31;   /* Register used to store return addr for JALR */
  }
}
namespace rigel {
  namespace predictor {
    const uint32_t GSHARE_ORDER = 9;
    const uint32_t GSHARE_SIZE = 1 << GSHARE_ORDER;
    const uint32_t GSHARE_HIST_LENGTH = 8;
  }
}

namespace rigel {
  // Cache namespace holding the compile-time cache configuration parameters
  namespace cache {
    const int LINESIZE = 32;
    const int LINESIZE_ORDER = rigel_log2(LINESIZE);
    // CONSTRAINT: LINESIZE*GCACHE_CONTIGUOUS_LINES*(G$ BANKS PER TILE == 4) %
    //   DRAM_COLUMN_SIZE === 0 => GCACHE_CONTIGUOUS_LINES can be a multiple of
    //   16.  Otherwise, a single DRAM column will map to >4 G$ banks, which
    //   will make it go across tiles
    const int GCACHE_CONTIGUOUS_LINES = 16;
    const int GCACHE_CONTIGUOUS_LINES_ORDER = rigel_log2(GCACHE_CONTIGUOUS_LINES);
    const uint32_t LINE_MASK = ~(LINESIZE - 1);
    const uint32_t GCACHE_MASK = ~(LINESIZE*GCACHE_CONTIGUOUS_LINES - 1);
    // These could be removed once we do the studies using them. 
    #ifndef EXTERN_L1D_SETS
      #define EXTERN_L1D_SETS 1
    #endif
    #ifndef EXTERN_L1D_WAYS
      #define EXTERN_L1D_WAYS 1
    #endif
    // L1D Sizing parameters.
    const int L1D_WAYS = 2; // EXTERN_L1D_SETS;
    const int L1D_SETS = 32; //EXTERN_L1D_WAYS;
    const int L1D_SIZE = L1D_SETS * L1D_WAYS * LINESIZE;
    // L1I Sizing parameters.
    const int L1I_WAYS = 8; //EXTERN_L1I_WAYS;
    const int L1I_SETS = EXTERN_L1I_SETS;
    const int L1I_SIZE = L1I_SETS * L1I_WAYS * LINESIZE;
    // L2I Sizing parameters.
    const int L2I_WAYS = EXTERN_L2I_WAYS;
    const int L2I_SETS = EXTERN_L2I_SETS;
    const int L2I_SIZE = L2I_SETS * L2I_WAYS * LINESIZE;
    // L2D Sizing parameters.
    const int L2D_WAYS = EXTERN_L2D_WAYS;   // L2
    const int L2D_SETS = EXTERN_L2D_SETS; // 64 KiB
    const int L2D_SIZE = L2D_SETS * L2D_WAYS * LINESIZE;
    // Enable counting writebacks on evictions rather than using MHSRs
    const bool ENABLE_WRITEBACK_COUNTING = false;
    // *************** L2 Interconnect ****************
    //// *** 8x8 XBar ***
    #if 0
    const int L2_BANKS = 8;
    const int L2_PORTS_PER_BANK = 1;
    const int L2_PORTS_TOTAL  = L2_BANKS * L2_PORTS_PER_BANK;
    const bool L2_SHARED_RW_PORTS = true; // seperate
    #else
    //// *** Shared 256-bit bus (default) ***
    const int L2D_BANKS = 1;
    // Number of ports to allow into the cluster cache per bank.  With a bus, it
    // is the total number of ports.  For a XBar it is only 1/# banks.  Defined
    // in src/util.cpp. Default: 1
    extern int L2D_PORTS_PER_BANK;
    // Started simulating two ports into the GCache as it provides a 10% boost
    // over baseline.  See wiki if interested.
    const int DEFAULT_L2D_PORTS_PER_BANK = 2;
    const bool L2D_SHARED_RW_PORTS = true;
    #endif
    const int L2I_BANKS = 1;
    const int L2I_PORTS_PER_BANK = 1;
    const bool L2I_SHARED_RW_PORTS = true;
    // GLOBAL CACHE: 128 KiB/Bank
    const int GCACHE_WAYS = 8;
#ifdef EXTERN_GCACHE_SETS
    const int GCACHE_SETS = EXTERN_GCACHE_SETS;
#else
    const int GCACHE_SETS = 1 << 9;
#endif
    const int GCACHE_SIZE = GCACHE_SETS * GCACHE_WAYS * LINESIZE;
    //How many G$ banks are assigned to each memory controller?
    //NOTE: This *must* be a power of two due to assumptions made in e.g. address_mapping.h
    const int GCACHE_BANKS_PER_MC = 4;
    const int GCACHE_BANKS_PER_MC_ORDER = rigel_log2(GCACHE_BANKS_PER_MC);
    // Number of MSHRs allowed for first level caches.  If there are N pending
    // misses and another one comes along, it must stall until one of the
    // currently pending requests is serviced.
    const int L1D_OUTSTANDING_MISSES = 32;
    // The I$ must have at least two outstanding misses to avoid a potential
    // deadlock situation that can occur when we have a direct or two-way
    // associative instruction cache.  Basically, the extra MSHRs give added
    // associativity thus closing the conflict/evict window of vulnerability
    // similar to what is described in Kubiatowicz et al.
    const int L1I_OUTSTANDING_MISSES = 8;
    // Number of MSHRs for L2I when using a separate L2 structure.
    const int L2I_OUTSTANDING_MISSES = 16;
    // We used to have 8 here but that will generate deadlocks in the
    // network since you may need to evict values to bring in new values.  We
    // might be safe with 8+N, but I think we may even need 16+N in the case
    // where there are 8 outstanding DCache misses and 8 outstanding ICache
    // misses and then you need another MHSR for an eviction.
    //
    // The N mentioned above is 1 in historic code but is now set to
    // L2_EVICTION_BUFFER.
    //
    // Note that these restrictions do not exist in the new CCache golden model
    // and the buffer sizes can be made arbitrarily small as long as certain
    // conditions are met.  We may want to visit the less accurate model here to
    // evaluate the potential for making the two match.
    //
    // Number of MSHRs to allow at the cluster cache.  Remember that there is
    // an associative lookup required on every miss in the cluster cache to
    // ensure that there are no RAW violations through the CCache FIFO that
    // this represents.
    const int L2D_EVICTION_BUFFER_SIZE = 8;
    const int L2I_EVICTION_BUFFER_SIZE = 0;
    const int L1D_EVICTION_BUFFER_SIZE = 0;
    const int L1I_EVICTION_BUFFER_SIZE = 0;
    const int GCACHE_EVICTION_BUFFER_SIZE = 4;
    // Since we do outstanding misses at compile time, we need to set a fixed
    // size for some of the structurs.
    const int MAX_L2D_OUTSTANDING_MISSES = 32;
    const int MAX_L2D_OUTSTANDING_PREFETCHES = 8;
    // Number of MSHRs allocated at the G$
    const size_t GCACHE_OUTSTANDING_MISSES = 64;
    // The number of replies that can be serviced at each G$ bank per cycle.
    // The value is defined in global_cache.cpp for now.
    extern size_t GCACHE_REPLY_PORTS_PER_BANK;
    extern size_t GCACHE_REQUEST_PORTS_PER_BANK;
    // Default number of ports per bank.  Brought into global_cache.cpp so we
    // can change them without full recompile/may cmdline-configurable.
    const size_t GCACHE_REPLY_PORTS_PER_BANK_DEFAULT = 2;
    const size_t GCACHE_REQUEST_PORTS_PER_BANK_DEFAULT = 2;
    // Number of cycles to wait on setting ACK/SCHED for a request.
    const int CACHEBASE_ACK_WDT = 20000;
    const int CACHEBASE_SCHED_WDT = 20000;
    // Number of attempts for a single memory access before aborting the simulator.
    //const int CACHEBASE_MEMACCESS_ATTEMPTS_WDT = 60000; // FIXME
    const int CACHEBASE_MEMACCESS_ATTEMPTS_WDT = 300000;
    // Number of cycles to stall at the directory before aborting.
    //const uint64_t DIRECTORY_STATE_WDT = 50000; // FIXME
    const uint64_t DIRECTORY_STATE_WDT = 200000;
    // Number of cycles to wait on a reply from the memory/GCache at the cluster
    // cache before aborting the simulator.
    //const int CCACHE_WDT_TIMEOUT = 80000; //FIXME
    const int CCACHE_WDT_TIMEOUT = 300000; 
    // Cache access latencies.  This is the time to turn around a request on a
    // hit without any restrictions such as port count or queuing.
    const int L1D_ACCESS_LATENCY = 1;
    const int L1I_ACCESS_LATENCY = 1;
    const int L2D_ACCESS_LATENCY = 2;
    const int L2I_ACCESS_LATENCY = 1;
    // The number of cycles to turn around a request at the global cache.  Not
    // the latency through the network! Defined in src/util.cpp.  Default has been '2'.
    extern int GCACHE_ACCESS_LATENCY;
    // Enable instructions to cache in the cluster cache.  Misses from the
    // first-level instruction caches will proble the CCache before requesting
    // a fill from the GCache.
    const bool USE_L2I_CACHE_UNIFIED = EXTERN_USE_L2I_CACHE_UNIFIED;
    // Create a separate shared L2 I$ for all cores in a cluster.  The shared L2 I$
    // will arbitrate for the cluster cache bus and send messages (instruction fetches)
    // to the global network via the cluster cache on misses.
    const bool USE_L2I_CACHE_SEPARATE = EXTERN_USE_L2I_CACHE_SEPARATE;
    // Model a perfect memory system with single-cycle access to all data.
    extern bool PERFECT_L1D;
    // Model a perfect instruction system with single-cycle access for all fetches.
    extern bool PERFECT_L1I;
    // Model perfect CCache.  Independent of perfect modeling of L1I/L1D.
    extern bool PERFECT_L2D;
    extern bool PERFECT_L2I;
    // Model perfect L2 I$.  Independent of perfect modeling of L1I/L1D/CCache.
    extern bool PERFECT_L2I;
    // Model perfect GCache, i.e., zero-latency/infinite bandwidth to memory.
    extern bool PERFECT_GLOBAL_CACHE;
    // Model global memory operations (g.stw, g.ldw, atom.XYZ) take zero time.
    extern bool PERFECT_GLOBAL_OPS;
    // Disable the line buffer and send all memory references directly to the
    // CCache.  By default it should be enabled in user.config.
    const bool L1D_ENABLED = EXTERN_L1D_ENABLED;
    // Eviction policies
    const int EVICT_LRU = 1;
    const int EVICT_RANDOM = 2;
    const int WRITE_BACK = 1;
    const int CACHE_WRITE_THROUGH = 2;
    // WDT Counts for the GCache and CCache to abort the simulator when a hang
    // is detected.
    const int GCACHE_PENDING_WDT_COUNT = 8*4096;
    const int CCACHE_PENDING_WDT_COUNT = 8*1024;
    // Number of cycles to let a request trying to Fill() at the cluster cache
    // stall before aborting.
    const int CLUSTER_REMOVE_WDT = 50000;
    // How often we print a warning to stderr for WDT expiry to keep from
    // flooding stderr with nearly identical messages.
    const int CACHE_PENDING_PRINT_THROTTLE = 4096;
    // Number of cycles to allow a message to remain resident in the network
    // or waiting on a memory request before aborting, respectively.
    const int NETWORK_OCCUPANCY_WDT_COUNT = 4*16384;
    const int NETWORK_MEM_WAIT_WDT_COUNT = 4*16384;
    // Stores never stall
    extern bool CMDLINE_FREE_WRITES;
    // Turn on write allocate at the cluster cache by default.
    const bool ENABLE_L2D_WRITEALLOCATE = true;
    // Allow prefetches to be dropped if not enough MSHRs available at the L2.
    // Defined in cmdline_parse.cpp.  Default: false.
    extern bool CMDLINE_NONBLOCKING_PREFETCH;
    // The number of cache lines to sequentially prefetch into the clsuter cache
    // on a miss.  Zero disables prefetching.  Negative values are undefined.
    // Default: 0
    extern int CMDLINE_CCPREFETCH_SIZE;
    extern bool CMDLINE_CCPREFETCH_STRIDE;
    // Number of sequential cache lines to prefetch from DRAM on a GCache miss.
    // Zero disables prefetching.  Default: 0
    extern int CMDLINE_GCACHE_PREFETCH_SIZE;
    const int DEFAULT_GCACHE_PREFETCH_SIZE = 4;
    // Should the G$ pend all prefetches as a single MSHR and DRAM request?
    // Defaults to false (separate MSHRs and DRAM requests for each cache line).
    // If true, prefetches will be truncated such that all are to the same DRAM row.
    extern bool GCACHE_BULK_PREFETCH;
    // Number of outstanding requests between any two G$/C$ pairs to allow
    // with coherence turned on.
    const int OUTSTANDING_GCACHE_TO_CCACHE_REQS = 32;
    // Number of pointers to allow in limited directory scheme before resorting to a
    // broadcast operation.
    extern uint32_t MAX_LIMITED_PTRS;
    const uint32_t DEFAULT_MAX_LIMITED_PTRS = 4;
    extern bool ENABLE_LIMITED_DIRECTORY;
    const bool DEFAULT_ENABLE_LIMITED_DIRECTORY = false;
    // This option turns the directory cache into a sort of snoop filter that
    // drops directory entries on an eviction.
    extern bool ENABLE_PROBE_FILTER_DIRECTORY;
    // Turn on a separate network channel for broadcasts.
    extern bool ENABLE_BCAST_NETWORK;
  }
}
namespace rigel {
  namespace memory {
    extern FILE *cctrace_out;
    extern FILE *dramtrace_out;
    extern FILE *coherencetrace_out;
    extern FILE *direvicttrace_out;
    // FIXME: this should be set to be the SAME as in the crt rigel mt thingy in lib/libc
    const uint32_t PER_THREAD_STACK_SIZE = (0x1UL << 18);
    // What value should all words in the memory model be initialized to when
    // they are first allocated.  Must be valid opcode (NOP).
    const uint32_t MEMORY_INIT_VALUE = 0x00000000;
  }
}
namespace rigel {
  // task_queue: Hardware task queue parameters.  The hardware task queue is
  // useful for fast prototyping of new ideas and represents an idealized model
  // for task scheduling.
  namespace task_queue {
    const int TQ_RET_REG = 24;
    const uint32_t TQ_REG0 = 25;
    const uint32_t TQ_REG1 = 26;
    const uint32_t TQ_REG2 = 27;
    const uint32_t TQ_REG3 = 28;
    const uint32_t QUEUE_MAX_SIZE = 128;
    // The latency incurred from the core's perspective for each operation
    extern int LATENCY_ENQUEUE_ONE;
    extern int LATENCY_ENQUEUE_LOOP;
    extern int LATENCY_DEQUEUE;
    // The delay from the queue realizing that all cores are blocking until when
    // it broadcasts the message that a sync point has been reached.
    extern int LATENCY_BLOCKED_SYNC;
    // Size of the hardware task structures
    const int INTERVAL_RECENT_STACK_SIZE = 128;
    const int INTERVAL_LIFO_STACK_SIZE = 128;
  }
}
namespace simconst {
  /* Use max_reg + 1 as the sentinel to note that this register is not used by
   * the instruction*/
  const uint32_t NULL_REG = rigel::NUM_REGS;
  const uint32_t SIMM16_REG = simconst::NULL_REG; // rigel::NUM_REGS+1;
  const uint32_t IMM16_REG = rigel::NUM_REGS+2;
  const uint32_t PC_REG = simconst::NULL_REG;     // rigel::NUM_REGS+3;
  const uint32_t VOID_RESULT = 0xDEADBEEF;
}

#include "memory/dram.h"

namespace rigel {
  namespace interconnect {
    // Amount of buffering at each router.  We also allow for the # req/cycle to be inserted.
    const size_t L1_ROUTER_ENTRIES = 32;
    const size_t L2_ROUTER_ENTRIES = 32;
    // Number of requests to route per L1 to the L2 router per cycle.
    const size_t L1_TO_L2_REQUESTS_PER_CYCLE = 2;
    const size_t L2_TO_GNET_REQUESTS_PER_CYCLE = 4;
    //Depth of GNet-side request buffers.
    const size_t MAX_ENTRIES_TILE_REQUEST_BUFFER = 16;
    const size_t MAX_ENTRIES_TILE_PROBE_RESP_BUFFER = 16;
    // Number of clusters that feed into a single router.
    const size_t CLUSTERS_PER_L1_ROUTER = 4;

    // Written by GNET, read by GCache.
    const size_t MAX_ENTRIES_GCACHE_PROBE_REQUEST_BUFFER = 64;
    const size_t MAX_ENTRIES_GCACHE_PROBE_RESP_BUFFER = 64;
    const size_t MAX_ENTRIES_GCACHE_REQUEST_BUFFER= 16;
    const size_t MAX_ENTRIES_GCACHE_REPLY_BUFFER = 64;
    // Written by GNet, read by tiles.
    const size_t MAX_ENTRIES_TILE_REPLY_BUFFER = 16;
    const size_t MAX_ENTRIES_TILE_PROBE_REQUEST_BUFFER = 16;
    // Number of messages to allow the GNet to route.
    // UP parameters refer to the clusters-to-global-cache route,
    // DOWN parameters refer to the global-cache-to-clusters route
    // INPUT means how many messages (max) do we allow to come from
    // a single input port in one cycle.
    // OUTPUT means how many messages (max) do we allow to go to
    // a single output port in one cycle.
    // A vanilla crossbar would have values 1-1-1-1.
    const size_t MAX_GNET_UP_INPUT_MESSAGES_PER_CYCLE = 2;
    const size_t MAX_GNET_UP_OUTPUT_MESSAGES_PER_CYCLE = 2;
    const size_t MAX_GNET_DOWN_INPUT_MESSAGES_PER_CYCLE = 2;
    const size_t MAX_GNET_DOWN_OUTPUT_MESSAGES_PER_CYCLE = 2;
    // Latency for crossing the GNET
    const size_t GNET_GC2TILE_LAT = 2;
  }
}
namespace rigel {
  namespace profiler {
    // Enables binning of instructions by PC and a dump to be produced on exit
    extern bool PROFILE_INSTRS;
    extern bool PROFILE_HIST_GCACHEOPS;
    extern std::string DUMP_FILENAME;
    const char gcacheops_histogram_dumpfile[32] = "gcacheops.dump";
    // Granularity of memory operation histograming
    extern int gcacheops_histogram_bin_size;
    // All possible operations tracked by the hotspot checker
    typedef enum {
      PROF_HIST_ATOMIC = 0,
      PROF_HIST_GLD,
      PROF_HIST_GST,
      PROF_HIST_LLD,
      PROF_HIST_EVICT,
      PROF_HIST_WRITEBACK,
      PROF_HIST_PREF,
      PROF_HIST_OTHER,  // For unsupported operations...fix later
      PROF_HIST_COUNT
    } profile_gcacheops_histogram_t;

    const char profile_gcacheops_names[PROF_HIST_COUNT][32] = {
      "Atomics",
      "Global Load",
      "Global Store",
      "Local Load",
      "Eviction",
      "Writeback",
      "Prefetch",
      "Other",
    };

    typedef enum {
      PROF_DRAM_READ = 0,
      PROF_DRAM_WRITE,
      PROF_DRAM_ACTIVATE,
      PROF_DRAM_PRECHARGE,
      PROF_DRAM_IDLE,
      PROF_DRAM_INVALID,
      PROF_DRAM_COUNT
    } profile_dram_histogram_t;

    const char profile_dram_names[PROF_DRAM_COUNT][32] = {
      "DRAM_READ",
      "DRAM_WRITE",
      "DRAM_ACTIVATE",
      "DRAM_PRECHARGE",
      "DRAM_IDLE",
      "INVALID"
    };

    // Holds the GCache operations histogram data.  The key is the cycle number and
    // the array holds each of the counts
    typedef
    std::map< uint64_t, std::map< int, std::map<profile_gcacheops_histogram_t, int> > >
                  GCacheOpProfType;
    // Holds the histogram data for commands going across the DRAM pins each
    // cycle.
    typedef std::map< uint64_t, std::map<profile_dram_histogram_t, int> >
                  DRAMOpProfType;
    // For each operation at the global cache, bin the number of cycles it takes
    // to complete.  Use geometric distribution for powers of two so that the
    // bins are 1, 2, 4, 8, 16, 32, 64, ..., etc.
    typedef std::map< uint64_t, std::map<int, int> > NetLatProfType;
    // Turn on to enable printing of per-pc statistics.  Defined in profile.cpp.
    extern bool CMDLINE_DUMP_PER_PC_STATS;
    const char per_pc_filename[] = "per-pc-profile.out";
    // Prefix to prepend to all dump files.  Defined in profile.cpp, set in
    // util.cpp.
    extern std::string DUMPFILE_PREFIX;
    // Track how many cores touch each cacheline while it is resident in the
    // cluster cache.  Handled in cache_model.cpp and tracked in CacheTag.
    // Defined in src/profile.cpp.
    extern uint64_t *ccache_access_histogram;
    extern uint64_t *icache_access_histogram;
    // List of all statistics used in simulator. Defined in profile.cpp.
    extern ProfileStat *stats;
  }
}

//This is at the bottom because it needs both MAX_MCS and GCACHE_BANKS_PER_MC to be declared first
namespace rigel {
  //Maximum number of global cache banks
  const int MAX_GCACHE_BANKS = MAX_MCS*rigel::cache::GCACHE_BANKS_PER_MC;
}

////////////////////////////////////////////////////////////////////////////////
// rigel_dump_backtrace()
////////////////////////////////////////////////////////////////////////////////
// dumps a backtrace when called
// defined as inline so it will not complain about multiple definitions
inline void rigel_dump_backtrace() {
  DEBUG_HEADER();
//FIXME make this check more robust
#ifdef __linux__
  void   *array[20];
  size_t size;
  size = backtrace(array, 20);
  backtrace_symbols_fd(array, size, 2);
#endif
  return;
};
#endif
