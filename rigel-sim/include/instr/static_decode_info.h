#include "autogen/autogen_isa_sim.h"
#include <stdint.h>
#include "sim.h" // ugh, this dependence...

enum isa_reg_t {
  SREG_S = 0,
  SREG_T,
  DREG,
  NUM_ISA_OPERAND_REGS
};

////////////////////////////////////////////////////////////////////////////////
/// holds statically-known decode information to avoid repetetive decodes
/// make this static decode packet structure per pc, set at first decode
////////////////////////////////////////////////////////////////////////////////
class StaticDecodeInfo {

  public:

    /// constructor
    StaticDecodeInfo() 
      :
      valid_(0),
      type_(I_PRE_DECODE)
    { };

    /// decode the instruction into useful/relevant fields
    void decode(uint32_t pc, uint32_t raw) {
      valid_ = true;
      pc_    = pc;
      raw_instr_bits = raw;

      sim_decode_type();
      StaticDecode();
      setRegs();
    }

    /// print useful information about the instruction
    void Dump() {
      printf("pc: 0x%08x raw: 0x%08x I_TYPE: %s\n", 
        pc_, raw_instr_bits, instr::instr_string[type_]);
    }

    // autogenerated
    int sim_decode_type();

    ///
    /// accessors
    ///

    /// get instruction fields
    /// TODO: auto-generate these routines
    // note: these are fragile (hardcoded), 
    // if the ISA changes they may have to be changed
    // Each of these obtains the values from the raw instruction bits
    /// FIXME: these should be private and insulated properties
    uint32_t optype(); /// autogenerated
    uint32_t opcode(); /// autogenerated 
    // FIXME autogenerate these
    uint32_t reg_d()  { return 0x0000001F & (raw_instr_bits >> 23);}
    uint32_t reg_t()  { return 0x0000001F & (raw_instr_bits >> 18);}
    uint32_t reg_s()  { return 0x0000001F & (raw_instr_bits >> 13);}
    uint32_t imm5()   { return 0x0000001F & (raw_instr_bits >> 13);}
    uint32_t imm16()  { return 0x0000FFFF & (raw_instr_bits >> 0 );}
    uint32_t imm26()  { return 0x03FFFFFF & (raw_instr_bits >> 0 );}

    uint32_t simm16() { return int32_t(int16_t(imm16()));}

    bool valid()   { return valid_; }
    instr_t type() { return type_; }

    /// TODO or not TODO:
    /// memoize some of these calls???
    /// functional units (or pipelines)
    bool    isBranch() const;
    bool    isBranchIndirect() const;
    bool    isBranchDirect() const;
    bool    isStoreLinkRegister() const;
    bool    isALU() const;
    bool    isFPU() const;
    /// memory
    bool    isMem() const;
    bool    isGlobal() const;
    bool    isLocalMem() const;
    bool    isLocalLoad() const; // (local? global?)
    bool    isLocalStore() const; // (local? global?)
    bool    isCacheControl() const; 
    /// atomics
    bool    isAtomic() const;
    bool    isStore() const;
    bool    isLoad() const;
    bool    isLocalAtomic() const;
    bool    isGlobalAtomic() const;
    /// other
    bool    isPrefetch() const;
    bool    isSimOp() const; 
    bool    isOther() const; 
    bool    isNOP() const; 
    bool    isSPRFSrc() const; 
    bool    isDREGSrc() const; 
    bool    isDREGNotDest() const;
    bool    isSPRFDest() const; 
    bool    isShift() const; 
    bool    isCompare() const; 
    // 
    bool    isSimSpecial() const; 

    void setType(instr_t t) {
      type_ = t;
    }

    /// record register names and dependencies for reg fields
    /// FIXME: autogenerate this per instruction...
    /// FIXME: AUDIT this CODE
    void setRegs() {
      // TODO FIXME: iterate these 3
      if(has_sreg_t) {
        regnums[SREG_T] = reg_t();
        input_deps[SREG_T] = reg_t();
        output_deps[SREG_T] = simconst::NULL_REG;
      } else {
        regnums[SREG_T] = simconst::NULL_REG;
        input_deps[SREG_T] = simconst::NULL_REG;
        output_deps[SREG_T] = simconst::NULL_REG;
      }
      // TODO FIXME: iterate
      if(has_sreg_s) {
        regnums[SREG_S] = reg_s();
        input_deps[SREG_S] = reg_s();
        output_deps[SREG_S] = simconst::NULL_REG;
      } else {
        regnums[SREG_S] = simconst::NULL_REG;
        input_deps[SREG_S] = simconst::NULL_REG;
        output_deps[SREG_S] = simconst::NULL_REG;
      }
      // TODO FIXME: iterate
      // FIXME: make sure these really read and/or write DREG
      if(has_dreg) {
        regnums[DREG]     = reg_d();
        // do we read the DREG field?
        if (isDREGSrc()) {
          input_deps[DREG]  = reg_d(); 
        } else {
          input_deps[DREG]  = simconst::NULL_REG;
        }
        // do we actually write the DREG field?
        if (isDREGNotDest()) { // no, we don't
          output_deps[DREG] = simconst::NULL_REG; 
        } else { // otherwise we do
          output_deps[DREG] = reg_d();
        }
      } else { // this may be caught above already...
        if (isStoreLinkRegister()) { // writes link reg
          regnums[DREG]     = rigel::regs::LINK_REG;
        } else {
          regnums[DREG]     = simconst::NULL_REG;
        }
        input_deps[DREG]  = simconst::NULL_REG;
        output_deps[DREG] = simconst::NULL_REG;
      }
    }

    uint32_t StaticDecode();

    int32_t regnums[NUM_ISA_OPERAND_REGS];
    int32_t input_deps[NUM_ISA_OPERAND_REGS];
    int32_t output_deps[NUM_ISA_OPERAND_REGS];

    // TODO FIXME make private
    bool has_dreg;
    bool has_sreg_t;
    bool has_sreg_s;
    bool has_imm5;
    bool has_imm16;
    bool has_imm26;

  private:
    ///
    /// private data members
    ///

    bool     valid_;

    /// basic decode information
    uint32_t pc_;
    uint32_t raw_instr_bits;
    instr_t  type_;  /// enum, the instruction type


    uint32_t decode_flags;

};
