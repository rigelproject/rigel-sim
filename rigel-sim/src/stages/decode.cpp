////////////////////////////////////////////////////////////////////////////////
// decode.cpp (Decoder)
////////////////////////////////////////////////////////////////////////////////
//
//  This file contains the decoder stage wrapper.  It includes the
//  auto-generated scoreboard logic and accesses the register file.
//
////////////////////////////////////////////////////////////////////////////////

#include <cassert>                      // for assert
#include <stdint.h>                     // for uint32_t
#include <cstdio>                       // for sprintf
#include <iostream>                     // for operator<<, basic_ostream, etc
#include <map>                          // for map
#include <string>                       // for string, operator<, etc
#include "../user.config"   // for ENABLE_VERIF
#include "cluster.h"        // for Cluster
#include "core.h"           // for CoreInOrderLegacy, ::DC2EX, ::IF2DC
#include "define.h"
#include "instr.h"          // for InstrLegacy
#include "instrstats.h"     // for InstrStats
#include "profile/profile.h"        // for InstrStat, Profile
#include "core/regfile_legacy.h"        // for RegisterBase
#include "sim.h"            // for ISSUE_WIDTH, NullInstr
#include "util/util.h"           // for ExitSim
#include "autogen/decode_switch.h"
#include "stage_base.h"  // for DecodeStage

////////////////////////////////////////////////////////////////////////////////
// Method Name: DecodeStage::Update()
////////////////////////////////////////////////////////////////////////////////
// Description: called each cycle to update state for decode stage
// Inputs: none
// Outputs: none
////////////////////////////////////////////////////////////////////////////////
void 
DecodeStage::Update() 
{

  //int tid = core->get_thread_id_core();
  // pointer to thread state
  //pipeline_per_thread_state_t *ts = core->get_thread_state(tid);

  for (int j = 0; j < rigel::ISSUE_WIDTH; j++) {
    InstrSlot instr_next = decode(core->latches[IF2DC][j], j);  
      if (!is_stalled(j)) {
        if (core->nlatches[DC2EX][j]->get_type() != I_NULL) { 
          // Account for "skipped" cores[i+x]->stage_name_here(latch...) calls
            core->get_cluster()->getProfiler()->timing_stats.dc_block += (rigel::ISSUE_WIDTH - j - 1);  
            break; 
        }
        core->latches[IF2DC][j] = rigel::NullInstr;
        core->nlatches[DC2EX][j] = instr_next;
      } 
   }
}

////////////////////////////////////////////////////////////////////////////////
// decode()
////////////////////////////////////////////////////////////////////////////////
// implements the decode stage
// calls the auto-generated "decode_switch.h" file
////////////////////////////////////////////////////////////////////////////////
InstrSlot
DecodeStage::decode(InstrSlot instr, int pipe) {
  bool stage_stall = (instr->get_type() == I_NULL);

  if (stage_stall) {
    // This is a stall cycle
    core->get_cluster()->getProfiler()->timing_stats.dc_bubble++;
  } else if (pipe > 0 && is_stalled(pipe-1)) {
    // If any previous pipe stalled, so does this one.
    core->get_cluster()->getProfiler()->timing_stats.dc_block++;
  } else {
    // Recycle decoded instructions that could not issue last cycle
    if (!instr->is_done_decode()) {
      // This was already counted as active in the cycle before it stalled
      //using namespace simconst;
      // Big nested switch statement covers all instructions
      // in autogenerated decoder_switch.h
      if (!sim_decode(instr)) {
				std::cerr << "Decoder Error: Thread " << instr->thread_id  
               << " encountered a bad opcode " << std::hex 
               << instr->get_raw_instr() << " @ PC 0x" << instr->get_currPC() 
               << "\n";
          char str[128];
          sprintf(str, "Unknown opcode: 0x%08x", instr->get_raw_instr());
          //ExitSim(str, 1);
          //assert(0 && "Unreachable");
          return instr;
      }
    }
    // Called from inside
    //decode_done:
    instr->set_done_decode();
    // Update decode type so we do not lose it when other stages overwrite the
    // type.
    instr->set_type_decode(instr->get_type());

    // Unstall stage
    unstall(pipe);
    core->get_cluster()->getProfiler()->timing_stats.dc_active++;
  }

  // Set instr type in statistics tracking class.
  if (I_NULL != instr->get_type()) {
    // Set the decoded instruction type
    instr->stats.decoded_instr_type = instr->get_type();

    if (instr->instr_is_local_memaccess()) instr->stats.is_memory_op = true;
    else { /* Add other type checking. */ }
  }
  return instr;

}


